<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>并发/Java创建线程的四种方式及其比较</title>
      <link href="/2020/07/02/%E5%B9%B6%E5%8F%91/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%AF%94%E8%BE%83/"/>
      <url>/2020/07/02/%E5%B9%B6%E5%8F%91/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p>Java线程实现/创建方式</p><h1 id="一、继承Thread类"><a href="#一、继承Thread类" class="headerlink" title="一、继承Thread类"></a>一、继承Thread类</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>其实Thread类本身也实现了Runnable接口，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线 程，并执行 run()方法。</p><h2 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyThread.run()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>MyThread myThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> myThread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><p>再如</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 创建线程对象</span>Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 要执行的任务</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 启动线程 t.start();</span></code></pre><h1 id="二-、实现Runnable类"><a href="#二-、实现Runnable类" class="headerlink" title="二 、实现Runnable类"></a>二 、实现Runnable类</h1><h2 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>使用Runnable配合Thread</p><p>把【线程】和【任务】（要执行的代码）分开 Thread 代表线程<br>Runnable 可运行的任务（线程要执行的代码）</p><h2 id="2、使用-1"><a href="#2、使用-1" class="headerlink" title="2、使用"></a>2、使用</h2><p>步骤：</p><ul><li>1、定义一个类实现Runnable接口；</li><li>2、创建该类的实例对象obj；</li><li>3、将obj作为构造器参数传入Thread类实例对象，这个对象才是真正的线程对象；</li><li>4、调用线程对象的start()方法启动该线程；</li></ul><pre class=" language-java"><code class="language-java">Runnable runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 要执行的任务</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建线程对象</span>Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span> runnable <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 启动线程</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>用 Runnable 更容易与线程池等高级 API 配合<br>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</p><p>再如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String ards<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Runnable implRunnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ImplRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>implRunnable<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//实现Runnable类，并重写run方法</span><span class="token keyword">class</span> <span class="token class-name">ImplRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"--"</span><span class="token operator">+</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>不论创建多少个线程，只需要创建一个Runnable接口实现类的对象</p><p>　　启动线程，new Thread（Runnable接口实现类的对象）.start()</p><p> 　创建线程调用的是Thread类Runable类型参数的构造器</p><h1 id="三、使用Callable和Future接口"><a href="#三、使用Callable和Future接口" class="headerlink" title="三、使用Callable和Future接口"></a>三、使用Callable和Future接口</h1><p>重写call方法（<strong>有返回值</strong>）</p><p>call方法比run方法更强大：有返回值，且可以声明抛出异常</p><h2 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。执行 Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务 返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程 了。</p><h2 id="2、使用-2"><a href="#2、使用-2" class="headerlink" title="2、使用"></a>2、使用</h2><p>步骤：</p><ol><li>创建一个Callable接口实现的对象，并重写call方法</li><li>创建一个FutureTask对象，传入Callable类型的参数,并接受返回值</li><li>使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）</li><li>调用FutureTask对象的get方法来获得子线程执行结束后的返回值</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String ards<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Callable<span class="token operator">&lt;</span>Integer<span class="token operator">></span> implCallable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ImplCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span>implCallable<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"----"</span><span class="token operator">+</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ImplCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            result <span class="token operator">+=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="3、Future接口控制Callable的方法"><a href="#3、Future接口控制Callable的方法" class="headerlink" title="3、Future接口控制Callable的方法"></a>3、Future接口控制Callable的方法</h2><p>&gt;boolean cancel(boolean mayInterruptIfRunning)：视图取消该Future里面关联的Callable任务</p><p>&gt;V get()：返回Callable里call（）方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值</p><p>&gt;V get(long timeout,TimeUnit unit)：返回Callable里call（）方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException</p><p>&gt;boolean isDone()：若Callable任务完成，返回True</p><p>&gt;boolean isCancelled()：如果在Callable任务正常完成前被取消，返回True</p><h1 id="四、基于线程池"><a href="#四、基于线程池" class="headerlink" title="四、基于线程池"></a>四、基于线程池</h1><h2 id="1、介绍-3"><a href="#1、介绍-3" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销 毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。</p><p>关于线程池的接口和实现类（注意他们的实现阶层实现关系）</p><p> Executor    负责现成的使用和调度的根接口</p><p>​        |–ExecutorService    线程池的主要接口</p><p>​            |–ThreadPoolExecutor    线程池的实现类</p><p>​            |–ScheduledExecutorService    接口，负责线程的调度</p><p>​                |–ScheduledThreadPoolExecutor    (extends ThreadPoolExecutor implements ScheduledExecutorService)</p><p>​                为Executors工具类提供了创建线程池的方法</p><h2 id="2、使用-3"><a href="#2、使用-3" class="headerlink" title="2、使用"></a>2、使用</h2><p>例1、线程池和Runnable接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPool</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用Executors工具类中的方法创建线程池</span>        ExecutorService pool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadPoolDemo demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//为线程池中的线程分配任务,使用submit方法，传入的参数可以是Runnable的实现类，也可以是Callable的实现类</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//关闭线程池</span>        <span class="token comment" spellcheck="true">//shutdown ： 以一种平和的方式关闭线程池，在关闭线程池之前，会等待线程池中的所有的任务都结束，不在接受新任务</span>        <span class="token comment" spellcheck="true">//shutdownNow ： 立即关闭线程池</span>        pool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ThreadPoolDemo</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**多线程的共享数据*/</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"---"</span><span class="token operator">+</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>例2、线程池和Callable接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPool2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Future<span class="token operator">&lt;</span>Integer<span class="token operator">></span> future <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        result <span class="token operator">+=</span> i<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"--"</span><span class="token operator">+</span>future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> ExecutionException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="五、创建方法的比较"><a href="#五、创建方法的比较" class="headerlink" title="五、创建方法的比较"></a>五、创建方法的比较</h1><p>基于线程池的创建方法只是在前几种创建方式的基础上增加了线程池，而实现Runnable和实现Callable接口的方式基本相同，不过是后者执行call()方法有返回值，因此，我们可以把这两种方法归为一种方式。因此，我们只要比较实现接口与继承Thread类：</p><h2 id="1、继承Thread的优缺点"><a href="#1、继承Thread的优缺点" class="headerlink" title="1、继承Thread的优缺点"></a>1、继承Thread的优缺点</h2><p>优点：</p><p>实现起来简单，而且要获取当前线程，无需调用Thread.currentThread()方法，直接使用this即可获取当前线程；</p><p>缺点：</p><ul><li>线程类已经继承Thread类了，就不能再继承其他类；</li><li>多个线程不能共享同一份资源（如前面分析的成员变量 i ）；</li></ul><h2 id="2、实现接口的优缺点"><a href="#2、实现接口的优缺点" class="headerlink" title="2、实现接口的优缺点"></a>2、实现接口的优缺点</h2><p>优点：</p><ul><li>线程类只是实现了接口，还可以继承其他类；</li><li>多个线程可以使用同一个target对象，适合多个线程处理同一份资源的情况。</li></ul><p>缺点：</p><ul><li>通过这种方式实现多线程，相较于第一类方式，编程较复杂；</li><li>要访问当前线程，必须调用Thread.currentThread()方法。</li></ul><p>注：一般采用实现接口的方法实现多线程</p><p>参考：</p><p><a href="https://www.cnblogs.com/duanjiapingjy/p/9434244.html" target="_blank" rel="noopener">https://www.cnblogs.com/duanjiapingjy/p/9434244.html</a></p><p><a href="https://www.cnblogs.com/3s540/p/7172146.html" target="_blank" rel="noopener">https://www.cnblogs.com/3s540/p/7172146.html</a></p><p><a href="https://blog.csdn.net/yangyechi/article/details/88079983" target="_blank" rel="noopener">https://blog.csdn.net/yangyechi/article/details/88079983</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring中Bean对象的创建和注入</title>
      <link href="/2019/09/23/Spring/Spring%E4%B8%ADBean%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/09/23/Spring/Spring%E4%B8%ADBean%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Bean的创建"><a href="#一、Bean的创建" class="headerlink" title="一、Bean的创建"></a>一、Bean的创建</h1><h2 id="1、构造方法创建"><a href="#1、构造方法创建" class="headerlink" title="1、构造方法创建"></a>1、构造方法创建</h2><p>方法：无参构造函数+字段的setter方法</p><p>注：我们不必在类中写任何构造函数，编译器会自己生成一个默认构造函数，如果我们 写了有参构造函数，就不会自动创建无参构造，也就不会创建Bean对象。</p><p>直接上代码：</p><p>xml配置</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.jc.service.impl.AccountServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre><h2 id="2、普通工厂中的方法创建"><a href="#2、普通工厂中的方法创建" class="headerlink" title="2、普通工厂中的方法创建"></a>2、普通工厂中的方法创建</h2><p>InstanceFactory类</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 模拟一个工厂类（该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数） */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InstanceFactory</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> IAccountService <span class="token function">getAccountService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AccountServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>xml配置</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>instanceFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.itheima.factory.InstanceFactory<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountService<span class="token punctuation">"</span></span> <span class="token attr-name">factory-bean</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>instanceFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getAccountService<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><h2 id="3、工厂中的静态方法创建"><a href="#3、工厂中的静态方法创建" class="headerlink" title="3、工厂中的静态方法创建"></a>3、工厂中的静态方法创建</h2><p>StaticFactory类</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 模拟一个工厂类（该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数） */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticFactory</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> IAccountService <span class="token function">getAccountService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AccountServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.itheima.factory.StaticFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getAccountService<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><h2 id="4、注解创建对象"><a href="#4、注解创建对象" class="headerlink" title="4、注解创建对象"></a>4、注解创建对象</h2><p>在创建对象的类上面使用注解就可以实现。</p><p>创建对象有四个注解。</p><p>@Conmponent<br>@Controller web层<br>@Service 业务层<br>@Repository 持久层</p><p>xml配置</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token comment" spellcheck="true">&lt;!-- bean definitions here --></span>    <span class="token comment" spellcheck="true">&lt;!--         开启注解的扫描，扫描类，方法，属性上面的注解    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">context:</span>component-scan</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre><h1 id="二、Bean的注入"><a href="#二、Bean的注入" class="headerlink" title="二、Bean的注入"></a>二、Bean的注入</h1><h2 id="1、构造器注入"><a href="#1、构造器注入" class="headerlink" title="1、构造器注入"></a>1、构造器注入</h2><p>使用的标签:constructor-arg；<br>标签出现的位置：bean标签的内部；</p><p>标签中的属性<br>    type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型<br>    index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始<br>    name：用于指定给构造函数中指定名称的参数赋值<br> ===============以上三个用于指定给构造函数中哪个参数赋值==============    </p><p>​    value：用于提供基本类型和String类型的数据<br>​    ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象</p><p>   优势：<br>     在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。<br>   弊端：<br>     改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.itheima.service.impl.AccountServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>泰斯特<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>18<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>now<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--date不是基本类型也不是String 如果使用vlaue="now"会报错--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 配置一个日期对象 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>now<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.util.Date<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><h2 id="2、setter方式注入-更常用"><a href="#2、setter方式注入-更常用" class="headerlink" title="2、setter方式注入(更常用)"></a>2、setter方式注入(更常用)</h2><p>如果要注入某个类的对象，需要创建set方法，如service中要用到dao成员变量，就要给这个dao创建set方法。</p><p>涉及的标签：property<br>出现的位置：bean标签的内部<br>标签的属性<br>     name：用于指定注入时所调用的set方法名称<br>     value：用于提供基本类型和String类型的数据<br>     ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象</p><p>   优势：<br>     创建对象时没有明确的限制，可以直接使用默认构造函数<br>   弊端：<br>     如果有某个成员必须有值，则获取对象是有可能set方法没有执行。</p><p> Person类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBirthday</span><span class="token punctuation">(</span>Date birthday<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>birthday <span class="token operator">=</span> birthday<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span>  <span class="token function">saveAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"service中的saveAccount方法执行了..."</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>age<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>birthday<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountService2<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.itheima.domain.Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TEST<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>21<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>now<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--name值是set方法名去掉set并都改为小写--></span></code></pre><h2 id="3、注解方式注入"><a href="#3、注解方式注入" class="headerlink" title="3、注解方式注入"></a>3、注解方式注入</h2><p>各注解说明：</p><p>1、Autowired:<br>      作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功<br>         如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。<br>         如果Ioc容器中有多个类型匹配时：<br>      出现位置：<br>        可以是变量上，也可以是方法上<br>      细节：<br>        在使用注解注入时，set方法就不是必须的了。</p><p>2、Qualifier:<br>     作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以（稍后我们讲）<br>      属性：<br>        value：用于指定注入bean的id。<br>3、Resource<br>     作用：直接按照bean的id注入。它可以独立使用<br>     属性：<br>        name：用于指定bean的id。<br>    以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。<br>    另外，集合类型的注入只能通过XML来实现。</p><p>4、Value<br>      作用：用于注入基本类型和String类型的数据<br>      属性：<br>       value：用于指定数据的值。它可以使用spring中SpEL(也就是spring的el表达式）<br>           SpEL的写法：${表达式}</p><p>例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@autowired</span>    <span class="token keyword">private</span> UserDao userDao<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Bean </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java创建线程的四种方式及其比较</title>
      <link href="/2019/08/23/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%AF%94%E8%BE%83/"/>
      <url>/2019/08/23/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h1 id="一、继承Thread类"><a href="#一、继承Thread类" class="headerlink" title="一、继承Thread类"></a>一、继承Thread类</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>其实Thread类本身也实现了Runnable接口，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线 程，并执行 run()方法。</p><h2 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyThread.run()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>MyThread myThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> myThread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><p>再如</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 创建线程对象</span>Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 要执行的任务</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 启动线程 t.start();</span></code></pre><h1 id="二-、实现Runnable类"><a href="#二-、实现Runnable类" class="headerlink" title="二 、实现Runnable类"></a>二 、实现Runnable类</h1><h2 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>使用Runnable配合Thread</p><p>把【线程】和【任务】（要执行的代码）分开 Thread 代表线程<br>Runnable 可运行的任务（线程要执行的代码）</p><h2 id="2、使用-1"><a href="#2、使用-1" class="headerlink" title="2、使用"></a>2、使用</h2><p>步骤：</p><ul><li>1、定义一个类实现Runnable接口；</li><li>2、创建该类的实例对象obj；</li><li>3、将obj作为构造器参数传入Thread类实例对象，这个对象才是真正的线程对象；</li><li>4、调用线程对象的start()方法启动该线程；</li></ul><pre class=" language-java"><code class="language-java">Runnable runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 要执行的任务</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建线程对象</span>Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span> runnable <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 启动线程</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>用 Runnable 更容易与线程池等高级 API 配合<br>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</p><p>再如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String ards<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Runnable implRunnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ImplRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>implRunnable<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//实现Runnable类，并重写run方法</span><span class="token keyword">class</span> <span class="token class-name">ImplRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"--"</span><span class="token operator">+</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>不论创建多少个线程，只需要创建一个Runnable接口实现类的对象</p><p>　　启动线程，new Thread（Runnable接口实现类的对象）.start()</p><p> 　创建线程调用的是Thread类Runable类型参数的构造器</p><h1 id="三、使用Callable和Future接口"><a href="#三、使用Callable和Future接口" class="headerlink" title="三、使用Callable和Future接口"></a>三、使用Callable和Future接口</h1><p>重写call方法（<strong>有返回值</strong>）</p><p>call方法比run方法更强大：有返回值，且可以声明抛出异常</p><h2 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。执行 Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务 返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程 了。</p><h2 id="2、使用-2"><a href="#2、使用-2" class="headerlink" title="2、使用"></a>2、使用</h2><p>步骤：</p><ol><li>创建一个Callable接口实现的对象，并重写call方法</li><li>创建一个FutureTask对象，传入Callable类型的参数,并接受返回值</li><li>使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）</li><li>调用FutureTask对象的get方法来获得子线程执行结束后的返回值</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String ards<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Callable<span class="token operator">&lt;</span>Integer<span class="token operator">></span> implCallable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ImplCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span>implCallable<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"----"</span><span class="token operator">+</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ImplCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            result <span class="token operator">+=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="3、Future接口控制Callable的方法"><a href="#3、Future接口控制Callable的方法" class="headerlink" title="3、Future接口控制Callable的方法"></a>3、Future接口控制Callable的方法</h2><p>&gt;boolean cancel(boolean mayInterruptIfRunning)：视图取消该Future里面关联的Callable任务</p><p>&gt;V get()：返回Callable里call（）方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值</p><p>&gt;V get(long timeout,TimeUnit unit)：返回Callable里call（）方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException</p><p>&gt;boolean isDone()：若Callable任务完成，返回True</p><p>&gt;boolean isCancelled()：如果在Callable任务正常完成前被取消，返回True</p><h1 id="四、基于线程池"><a href="#四、基于线程池" class="headerlink" title="四、基于线程池"></a>四、基于线程池</h1><h2 id="1、介绍-3"><a href="#1、介绍-3" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销 毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。</p><p>关于线程池的接口和实现类（注意他们的实现阶层实现关系）</p><p> Executor    负责现成的使用和调度的根接口</p><p>​        |–ExecutorService    线程池的主要接口</p><p>​            |–ThreadPoolExecutor    线程池的实现类</p><p>​            |–ScheduledExecutorService    接口，负责线程的调度</p><p>​                |–ScheduledThreadPoolExecutor    (extends ThreadPoolExecutor implements ScheduledExecutorService)</p><p>​                为Executors工具类提供了创建线程池的方法</p><h2 id="2、使用-3"><a href="#2、使用-3" class="headerlink" title="2、使用"></a>2、使用</h2><p>例1、线程池和Runnable接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPool</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用Executors工具类中的方法创建线程池</span>        ExecutorService pool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadPoolDemo demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//为线程池中的线程分配任务,使用submit方法，传入的参数可以是Runnable的实现类，也可以是Callable的实现类</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//关闭线程池</span>        <span class="token comment" spellcheck="true">//shutdown ： 以一种平和的方式关闭线程池，在关闭线程池之前，会等待线程池中的所有的任务都结束，不在接受新任务</span>        <span class="token comment" spellcheck="true">//shutdownNow ： 立即关闭线程池</span>        pool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ThreadPoolDemo</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**多线程的共享数据*/</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"---"</span><span class="token operator">+</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>例2、线程池和Callable接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPool2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Future<span class="token operator">&lt;</span>Integer<span class="token operator">></span> future <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        result <span class="token operator">+=</span> i<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"--"</span><span class="token operator">+</span>future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> ExecutionException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="五、创建方法的比较"><a href="#五、创建方法的比较" class="headerlink" title="五、创建方法的比较"></a>五、创建方法的比较</h1><p>基于线程池的创建方法只是在前几种创建方式的基础上增加了线程池，而实现Runnable和实现Callable接口的方式基本相同，不过是后者执行call()方法有返回值，因此，我们可以把这两种方法归为一种方式。因此，我们只要比较实现接口与继承Thread类：</p><h2 id="1、继承Thread的优缺点"><a href="#1、继承Thread的优缺点" class="headerlink" title="1、继承Thread的优缺点"></a>1、继承Thread的优缺点</h2><p>优点：</p><p>实现起来简单，而且要获取当前线程，无需调用Thread.currentThread()方法，直接使用this即可获取当前线程；</p><p>缺点：</p><ul><li>线程类已经继承Thread类了，就不能再继承其他类；</li><li>多个线程不能共享同一份资源（如前面分析的成员变量 i ）；</li></ul><h2 id="2、实现接口的优缺点"><a href="#2、实现接口的优缺点" class="headerlink" title="2、实现接口的优缺点"></a>2、实现接口的优缺点</h2><p>优点：</p><ul><li>线程类只是实现了接口，还可以继承其他类；</li><li>多个线程可以使用同一个target对象，适合多个线程处理同一份资源的情况。</li></ul><p>缺点：</p><ul><li>通过这种方式实现多线程，相较于第一类方式，编程较复杂；</li><li>要访问当前线程，必须调用Thread.currentThread()方法。</li></ul><p>注：一般采用实现接口的方法实现多线程</p><p>参考：</p><p><a href="https://www.cnblogs.com/duanjiapingjy/p/9434244.html" target="_blank" rel="noopener">https://www.cnblogs.com/duanjiapingjy/p/9434244.html</a></p><p><a href="https://www.cnblogs.com/3s540/p/7172146.html" target="_blank" rel="noopener">https://www.cnblogs.com/3s540/p/7172146.html</a></p><p><a href="https://blog.csdn.net/yangyechi/article/details/88079983" target="_blank" rel="noopener">https://blog.csdn.net/yangyechi/article/details/88079983</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发与多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java锁详解</title>
      <link href="/2019/08/23/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81%E8%AF%A6%E8%A7%A3/Java%E9%94%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/08/23/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81%E8%AF%A6%E8%A7%A3/Java%E9%94%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>马上就要开始秋招了，我们面试中经常会被问到各种各样的锁，在此做个总结。</p><p>以下这些锁并不全指锁的状态，有的指锁的特性，有的指锁的设计。</p><h1 id="一、乐观锁-悲观锁"><a href="#一、乐观锁-悲观锁" class="headerlink" title="一、乐观锁/悲观锁"></a>一、乐观锁/悲观锁</h1><p><img src="img%5C%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB.png" alt=""></p><p>（图片摘自<a href="https://www.cnblogs.com/jyroy/p/11365935.html）" target="_blank" rel="noopener">https://www.cnblogs.com/jyroy/p/11365935.html）</a></p><p>乐观锁和悲观锁是一种广义上的概念，体现了看线程同步的不同角度，因此，锁从广义上就分为乐观锁和悲观锁。</p><p>乐观锁：就是乐观思想，每次去哪数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制（在写时先读出当前的版本号，比较跟上一次的版本号，如果一样则更新）。<strong>乐观锁读多写少，遇到并发写的可能性较低</strong>。因此<strong>乐观锁适用于多读</strong>的应用类型，这样可以提高吞吐量。乐观锁在Java中的使用，是无锁编程，基本是通过CAS操作来实现的。典型的例子就是原子类，通过CAS自锁实现原子操作的更新，比较当前值跟传入值是否一样，一样则更新，否则失败。</p><p>悲观锁：就是悲观思想，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。比如Java里面的同步原语synchronized关键字的实现就是悲观锁，AQS框架下的锁则是先尝试CAS乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。<strong>悲观锁适合写操作非常多的场景</strong>，先加锁可以保证写操作时数据正确。<strong>Java中，synchronized关键字和Lock的实现类都是悲观锁。</strong></p><h2 id="1、乐观锁"><a href="#1、乐观锁" class="headerlink" title="1、乐观锁"></a>1、乐观锁</h2><p>乐观锁每次去取数据的时候，总会认为不会有其他线程对数据进行修改，因此不会上锁。但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用“数据版本机制”或“CAS操作“来实现。</p><p>（1）数据版本机制</p><p>一种是使用版本号，另一种是使用时间戳。以版本号为例。一般是在数据表中加上一个版本号version字段，表示数据被修改的次数，一旦数据被修改，version就会加一。当线程要重新更新数据时，也会同时读取version值，在提交更新时，若刚才读取到的version为当前数据库中的version值相等时才更新，否则重新更新操作，直到更新成功。</p><p>他和悲观锁的区别也正体现在这里，他认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而只是<strong>在提交更新时，才会正式对数据冲突与否进行检测</strong>。因此我们说乐观锁适用于多读。</p><p>（2）CAS操作</p><p>CAS（Compare and Swap）的中文意思就是比较并交换，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p><p>CAS操作中包含三个操作数——需要读写的内存位置(V)、进行比较的预期原值(A)和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B，否则处理器不做任何操作。</p><h2 id="2、悲观锁"><a href="#2、悲观锁" class="headerlink" title="2、悲观锁"></a>2、悲观锁</h2><p>悲观锁指对数据被外界修改持保守态度，认为数据很容易被其他线程修改，所以在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据 处于锁定状态。悲观锁的实现往往依靠数据库提供的锁机制，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败，就说明其他线程正在修改此记录，当前线程等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提提交事务后释放排它锁。</p><p>使用悲观锁、乐观锁来避免多线程同时对一个记录进行修改的代码例子见《并发编程之美》p72</p><h1 id="二、独占锁-共享锁"><a href="#二、独占锁-共享锁" class="headerlink" title="二、独占锁/共享锁"></a>二、独占锁/共享锁</h1><p>Java 并发包提供的加锁模式分为独占锁和共享锁。</p><h2 id="1、独占锁"><a href="#1、独占锁" class="headerlink" title="1、独占锁"></a>1、独占锁</h2><p>独占锁也叫排它锁，独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。 独占锁是一种悲观保守的加锁策略，每次访问资源都会先加上互斥锁，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就<strong>限制了不必要的并发性，因为读操作并不会影响数据的一致性</strong>。</p><h2 id="2、共享锁"><a href="#2、共享锁" class="headerlink" title="2、共享锁"></a>2、共享锁</h2><p>共享锁则允许多个线程同时获取锁，并发访问共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p><h1 id="三、互斥锁-读写锁"><a href="#三、互斥锁-读写锁" class="headerlink" title="三、互斥锁/读写锁"></a>三、互斥锁/读写锁</h1><p>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。</p><p>互斥锁在Java中的具体实现就是ReentrantLock。</p><p>读写锁在Java中的具体实现就是ReadWriteLock。</p><h1 id="四、可重入锁"><a href="#四、可重入锁" class="headerlink" title="四、可重入锁"></a>四、可重入锁</h1><p>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。</p><p>当一个线程要获取被其他现场持有的独占锁时，该线程会被阻塞，但如果一个线程获取他自己已经获取的锁不会阻塞，那我们就称这个锁为可重入锁，也就是说只要该线程获取了该锁，那么可以无限次数地进入被该锁锁住的代码。</p><p>例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hello</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">helloA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">helloB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">helloA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>调用helloB方法前会先获取内置锁，然后打印输出。之后，调用helloA方法，在调用前会先去获取内置锁，如果内置锁不是可重入的，那么调用线程将会一直被阻塞。</p><p>在以上代码中，synchronized内部锁是可重入锁。可重入锁的原理是在锁内部维护一个线程标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器。一开始计数器值为0，说明该锁没有被任何线程占用，当一个线程获取了该锁时，计数器的值就会变成1，这时其他线程再来获取该锁时会发现锁的所有者不是自己而被阻塞挂起。</p><p>但是当获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值加1，当释放锁后计数器值-1.当 计数器值为0时，锁里面的线程标示被重置为null，这时候被阻塞的线程会被唤醒来竞争获取该锁。</p><p>以上代码如果不是用的可重入锁，helloA()可能就不会被当前线程执行，可能造成死锁。</p><h1 id="五、公平锁-非公平锁"><a href="#五、公平锁-非公平锁" class="headerlink" title="五、公平锁/非公平锁"></a>五、公平锁/非公平锁</h1><h2 id="1、公平锁"><a href="#1、公平锁" class="headerlink" title="1、公平锁"></a>1、公平锁</h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。即加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得。<br>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><h2 id="2、非公平锁"><a href="#2、非公平锁" class="headerlink" title="2、非公平锁"></a>2、非公平锁</h2><p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。<br>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列</p><p>对于Java ReetrantLock而言，通过构造函数指定该锁是否是公平锁，<strong>默认是非公平锁</strong>。</p><p>对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><h2 id="3、举例"><a href="#3、举例" class="headerlink" title="3、举例"></a>3、举例</h2><p>ReentrantLock 默认是不公平的</p><pre class=" language-java"><code class="language-java">ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">500</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 1s 之后去争抢锁</span>Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" start..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"强行插入"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>强行插入，有机会在中间输出<br>注意：该实验不一定总能复现</p><pre><code>t39 running... t40 running... t41 running... t42 running... t43 running... 强行插入 start...强行插入 running... t44 running...t45 running...t46 running...t47 running...t49 running...</code></pre><p>通过构造函数改为公平锁：</p><pre class=" language-java"><code class="language-java">ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>强行插入，总是在最后输出</p><pre><code>t465 running... t464 running... t477 running... t442 running... t468 running... t493 running... t482 running... t485 running... t481 running... 强行插入 running...</code></pre><p>公平锁一般没有必要，会降低并发度</p><h1 id="六、分段锁"><a href="#六、分段锁" class="headerlink" title="六、分段锁"></a>六、分段锁</h1><p>​        分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p><p>　　我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7和JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）。</p><p>　　当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</p><p>　　但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。</p><p>　　分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p><h1 id="七、无锁-偏向锁-轻量级锁-重量级锁"><a href="#七、无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="七、无锁/偏向锁/轻量级锁/重量级锁"></a>七、无锁/偏向锁/轻量级锁/重量级锁</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>​        锁的状态一共有四种：无锁、偏向锁、轻量级锁和重量级锁。</p><p>　    这四种锁都是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p><p>​        首先为什么Synchronized能实现线程同步？<br>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p><p>（1）Java对象头</p><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p><p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><p>Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><p>Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p>（2）Monitor</p><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p><p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p><p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>​        我们可以以一个小故事来说明偏向锁、轻量级锁和 monitor的关系<br>故事角色</p><ul><li>老王 - JVM</li><li>小南 - 线程 </li><li>小女 - 线程 </li><li>房间 - 对象 </li><li>房间门上 - 防盗锁 - Monitor</li><li>房间门上 - 小南书包 - 轻量级锁</li><li>房间门上 - 刻上小南大名 - 偏向锁</li><li>批量重刻名 - 一个类的偏向锁撤销到达 20 阈值</li></ul><p>不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向</p><p>小南要使用房间保证计算不被其它人干扰（原子性），最初，他用的是防盗锁，当上下文切换时，锁住门。这样， 即使他离开了，别人也进不了门，他的工作就是安全的。<br>但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女 晚上用。每次上锁太麻烦了，有没有更简单的办法呢？<br>小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因 此每次进门前得翻翻书包，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是 自己的，那么就在门外等，并通知对方下次用锁门的方式。<br>后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍 然觉得麻烦。<br>于是，小南干脆在门上刻上了自己的名字：【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那 么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦 掉，升级为挂书包的方式。<br>同学们都放假回老家了，小南就膨胀了，在 20 个房间刻上了自己的名字，想进哪个进哪个。后来他自己放假回老 家了，这时小女回来了（她也要用这些房间），结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老 王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字<br>后来，刻名的现象越来越频繁，老王受不了了：算了，这些房间都不能刻名了，只能挂书包</p><p>​        锁升级：随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的， 也就是说只能从低到高升级，不会出现锁的降级）</p><h2 id="2、无锁"><a href="#2、无锁" class="headerlink" title="2、无锁"></a>2、无锁</h2><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><h2 id="3、轻量级锁"><a href="#3、轻量级锁" class="headerlink" title="3、轻量级锁"></a>3、轻量级锁</h2><p>​        轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><h2 id="4、偏向锁"><a href="#4、偏向锁" class="headerlink" title="4、偏向锁"></a>4、偏向锁</h2><p>　　偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p><p>​        在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><p>​        当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p><p>​        偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>​        偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p><h2 id="5、重量级锁"><a href="#5、重量级锁" class="headerlink" title="5、重量级锁"></a>5、重量级锁</h2><p>　　重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。</p><p>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p><h1 id="八、自旋锁"><a href="#八、自旋锁" class="headerlink" title="八、自旋锁"></a>八、自旋锁</h1><p>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><h1 id="九、Synchronized同步锁"><a href="#九、Synchronized同步锁" class="headerlink" title="九、Synchronized同步锁"></a>九、Synchronized同步锁</h1><p>synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重<br>入锁。</p><h2 id="1、Synchronized-作用范围"><a href="#1、Synchronized-作用范围" class="headerlink" title="1、Synchronized 作用范围"></a>1、Synchronized 作用范围</h2><ul><li>作用于方法时，锁住的是对象的实例(this)；</li><li>当作用于静态方法时，锁住的是 Class 实例，又因为 Class 的相关数据存储在永久带 PermGen<br>（jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁， 会锁所有调用该方法的线程；</li><li>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列， 当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</li></ul><h2 id="2、Synchronized-核心组件"><a href="#2、Synchronized-核心组件" class="headerlink" title="2、Synchronized 核心组件"></a>2、Synchronized 核心组件</h2><p>1) Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；<br>2) Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；<br>3) Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；<br>4) OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；<br>5) Owner：当前已经获取到所资源的线程被称为 Owner；<br>6) !Owner：当前释放锁的线程。</p><h2 id="3、Synchronized-实现"><a href="#3、Synchronized-实现" class="headerlink" title="3、Synchronized 实现"></a>3、Synchronized 实现</h2><p>![](img\Synchronized 实现.png)</p><ol><li>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下， ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将 一部分线程移动到 EntryList 中作为候选竞争线程。</li><li>Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定 EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。</li><li>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck， OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在 JVM 中，也把这种选择行为称之为“竞争切换”。</li><li>OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList 中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify 或者 notifyAll 唤醒，会重新进去 EntryList 中。</li><li>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统 来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。</li><li>Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先 尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是 不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁 资源。</li><li>每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加<br>上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的</li><li>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线<br>程加锁消耗的时间比有用操作消耗的时间更多。</li><li>Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向<br>锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做 了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。</li><li>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；</li><li>JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。</li></ol><h1 id="十、ReadWriteLock-读写锁"><a href="#十、ReadWriteLock-读写锁" class="headerlink" title="十、ReadWriteLock 读写锁"></a>十、ReadWriteLock 读写锁</h1><p>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如<br>果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写 锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。<br>读锁<br>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁<br>写锁<br>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上 读锁，写的时候上写锁！<br>Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现 ReentrantReadWriteLock。</p><p>参考：</p><p><a href="https://www.cnblogs.com/hustzzl/p/9343797.html" target="_blank" rel="noopener">https://www.cnblogs.com/hustzzl/p/9343797.html</a></p><p><a href="https://www.cnblogs.com/jyroy/p/11365935.html" target="_blank" rel="noopener">https://www.cnblogs.com/jyroy/p/11365935.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发与多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的线程状态及其相互转换</title>
      <link href="/2019/08/11/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/08/11/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="一、五个状态概述"><a href="#一、五个状态概述" class="headerlink" title="一、五个状态概述"></a>一、五个状态概述</h1><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。</p><p>在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞 (Blocked)和死亡(Dead)5 种状态。尤其是当线程启动以后，它不可能一直”霸占”着 CPU 独自 运行，所以 CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换</p><h2 id="1、初始状态（new）"><a href="#1、初始状态（new）" class="headerlink" title="1、初始状态（new）"></a>1、初始状态（new）</h2><p>实现Runnable、Callable接口或继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态</p><p>仅是在语言层面创建了线程对象，还未与操作系统线程关联 </p><h2 id="2、可运行状态（Runnable）"><a href="#2、可运行状态（Runnable）" class="headerlink" title="2、可运行状态（Runnable）"></a>2、可运行状态（Runnable）</h2><p>（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行 ，只是有资格运行，时间片没有轮到，就永远都是可运行状态</p><p>何时进入可运行状态：</p><ul><li>线程调用start()方法，可进入该状态；</li><li>当前线程sleep()方法结束，可进入该状态；</li><li>其他线程join()方法结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也可进入该状态；</li><li>当前线程时间片用完 了，调用当前线程的yield()方法，当前线程进入该状态；</li><li>锁池里的线程拿到对象锁后，进入该状态。</li></ul><h2 id="3、运行状态（Running）"><a href="#3、运行状态（Running）" class="headerlink" title="3、运行状态（Running）"></a>3、运行状态（Running）</h2><p>指获取了 CPU 时间片运行中的状态，这也是线程进入运行状态的<strong>唯一方式</strong>。<br>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 </p><h2 id="4、阻塞状态（Blocked）"><a href="#4、阻塞状态（Blocked）" class="headerlink" title="4、阻塞状态（Blocked）"></a>4、阻塞状态（Blocked）</h2><p>如何进入阻塞状态：</p><ul><li>当前线程调用Thread.sleep()方法，当前线程进入该状态；</li><li>运行在当前线程里的其他线程调用join()方法，当前线程进入该状态；</li><li>等待用户输入的时候，当前线程进入该状态；</li></ul><p>阻塞状态结束后进入可运行状态，等待调度</p><p>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑 调度它们</p><h2 id="5、死亡状态（Dead）"><a href="#5、死亡状态（Dead）" class="headerlink" title="5、死亡状态（Dead）"></a>5、死亡状态（Dead）</h2><p>表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p><p>有两个原因会导致线程死亡：</p><ul><li>当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。</li><li>一个未捕获的异常终止了run方法而使线程猝死。</li></ul><p>在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p><p> 为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false.</p><h1 id="二、线程状态之间的转换"><a href="#二、线程状态之间的转换" class="headerlink" title="二、线程状态之间的转换"></a>二、线程状态之间的转换</h1><p>以上的五种状态是从操作系统层面来描述的。</p><p>从Java API层面描述有六种状态：</p><ul><li>NEW：即前一节所述的初始状态；</li><li>RUNNABLE：当调用了 start()  方法之后，注意，Java API 层面的 RUNNABLE  状态涵盖了 操作系统 层面的<br>【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行）</li><li>阻塞状态：BLOCKED ， WAITING ， TIMED_WAITING  都是 Java API 层面对【阻塞状态】的细分</li><li>TERMINATED ： 当线程代码运行结束</li></ul><p><img src="img%5C%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt=""></p><h2 id="1、NEW–-gt-RUNNABLE"><a href="#1、NEW–-gt-RUNNABLE" class="headerlink" title="1、NEW–&gt;RUNNABLE"></a>1、NEW–&gt;RUNNABLE</h2><p>当调用 t.start()  方法时，由 NEW –&gt; RUNNABLE</p><h2 id="2-、RUNNABLE-lt-–-gt-WAITING"><a href="#2-、RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="2 、RUNNABLE  &lt;–&gt;WAITING"></a>2 、RUNNABLE  &lt;–&gt;WAITING</h2><p>t 线程用 synchronized(obj)  获取了对象锁后</p><ul><li><p>调用 obj.wait()  方法时，t 线程从 RUNNABLE –&gt; WAITING</p></li><li><p>调用 obj.notify() ， obj.notifyAll() ， t.interrupt()  时 </p><p>1）竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE</p><p>2）竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</p></li></ul><p>例：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestWaitNotify</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">static</span> Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>             <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>                 log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"执行...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">try</span> <span class="token punctuation">{</span>                     obj<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                     e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                 log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"其它代码...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 断点</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>             <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>                 log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"执行...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">try</span> <span class="token punctuation">{</span>                     obj<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                     e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                 log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"其它代码...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 断点</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"唤醒 obj 上其它线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>            obj<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 唤醒obj上所有等待线程  断点 </span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="3、-RUNNABLE-lt-–-gt-WAITING"><a href="#3、-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="3、 RUNNABLE &lt;–&gt; WAITING"></a>3、 RUNNABLE &lt;–&gt; WAITING</h2><p>1）当前线程调用 t.join()  方法时，当前线程从 RUNNABLE –&gt; WAITING<br>                注意是当前线程在t 线程对象的监视器上等待</p><p>2）t 线程运行结束，或调用了当前线程的 interrupt()  时，当前线程从 WAITING –&gt; RUNNABLE</p><h2 id="4、RUNNABLE-lt-–-gt-WAITING"><a href="#4、RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="4、RUNNABLE &lt;–&gt; WAITING"></a>4、RUNNABLE &lt;–&gt; WAITING</h2><ul><li>当前线程调用 LockSupport.park()  方法会让当前线程从 RUNNABLE –&gt; WAITING</li><li>调用 LockSupport.unpark(目标线程)  或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li></ul><h2 id="5、RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#5、RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="5、RUNNABLE &lt;–&gt; TIMED_WAITING"></a>5、RUNNABLE &lt;–&gt; TIMED_WAITING</h2><p>t 线程用 synchronized(obj)  获取了对象锁后<br>调用 obj.wait(long n)  方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING<br>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt()  时 竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE<br>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</p><h2 id="6、RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#6、RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="6、RUNNABLE &lt;–&gt; TIMED_WAITING"></a>6、RUNNABLE &lt;–&gt; TIMED_WAITING</h2><ul><li>当前线程调用 t.join(long n)  方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING <pre><code>    注意是当前线程在t 线程对象的监视器上等待</code></pre></li><li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt()  时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li></ul><h2 id="7、RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#7、RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="7、RUNNABLE &lt;–&gt; TIMED_WAITING"></a>7、RUNNABLE &lt;–&gt; TIMED_WAITING</h2><ul><li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING </li><li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li></ul><h2 id="8、RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#8、RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="8、RUNNABLE &lt;–&gt; TIMED_WAITING"></a>8、RUNNABLE &lt;–&gt; TIMED_WAITING</h2><ul><li>当前线程调用 LockSupport.parkNanos(long nanos)  或 LockSupport.parkUntil(long millis)  时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING</li><li>调用 LockSupport.unpark(目标线程)  或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从<br>TIMED_WAITING–&gt; RUNNABLE</li></ul><h2 id="9、RUNNABLE-lt-–-gt-BLOCKED"><a href="#9、RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="9、RUNNABLE &lt;–&gt; BLOCKED"></a>9、RUNNABLE &lt;–&gt; BLOCKED</h2><ul><li>t 线程用 synchronized(obj)  获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED</li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED  的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED</li></ul><h2 id="10、RUNNABLE-lt-–-gt-TERMINATED"><a href="#10、RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="10、RUNNABLE &lt;–&gt; TERMINATED"></a>10、RUNNABLE &lt;–&gt; TERMINATED</h2><p>当前线程所有代码运行完毕，进入 TERMINATED</p><p>整理自黑马培训班笔记，侵删！！！</p>]]></content>
      
      
      <categories>
          
          <category> 并发与多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程常用方法详解</title>
      <link href="/2019/07/12/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/Java%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/07/12/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/Java%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1、start"><a href="#1、start" class="headerlink" title="1、start()"></a>1、start()</h1><h2 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h2><p>启动一个新线程，在新的线程运行run方法中的代码。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>start方法只是让线程从新建状态进入就绪队列排队，一旦轮到它来享用CPU资源时，就可以脱离创建它的线程独立开始自己的生命周期了。里面代码不一定立刻 运行（CPU 的时间片还没分给它）。每个线程对象的 start方法只能调用一次，如果调用了多次会出现<br>IllegalThreadStateException</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token string">"t1"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             FileReader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>Constants<span class="token punctuation">.</span>MP4_FULL_PATH<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"do other things ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出</p><pre><code>19:41:30 [main] c.TestStart - do other things ...19:41:30 [t1] c.TestStart - t119:41:30 [t1] c.FileReader - read [1.mp4] start ...19:41:35 [t1] c.FileReader - read [1.mp4] end ... cost: 4542 ms</code></pre><h1 id="2、run"><a href="#2、run" class="headerlink" title="2、run()"></a>2、run()</h1><h2 id="功能说明-1"><a href="#功能说明-1" class="headerlink" title="功能说明"></a>功能说明</h2><p>新线程启动后会 调用的方法</p><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><p>​        （1）把需要处理的代码放到run()方法中，start()方法启动线程将自动调用run()方法，这个由java的内存机制规定的。并且run()方法必需是public访问权限，返回值类型为void。</p><p>​        （2）如果在构造 Thread 对象时传递了 Runnable 参数，则 线程启动后会调用 Runnable 中的 run 方法，否则默 认不执行任何操作。但可以创建 Thread 的子类对象， 来覆盖默认行为</p><p>​        （3）run()和start()之间的区别</p><ul><li>直接调用 run 是在主线程中执行了 run，没有启动新的线程</li><li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li></ul><h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token string">"t1"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             FileReader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>Constants<span class="token punctuation">.</span>MP4_FULL_PATH<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"do other things ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出</p><pre><code>19:39:14 [main] c.TestStart - main19:39:14 [main] c.FileReader - read [1.mp4] start ...19:39:18 [main] c.FileReader - read [1.mp4] end ... cost: 4227 ms 19:39:18 [main] c.TestStart - do other things ...</code></pre><h1 id="3、sleep-long-n"><a href="#3、sleep-long-n" class="headerlink" title="3、sleep(long n)"></a>3、sleep(long n)</h1><h2 id="功能说明-2"><a href="#功能说明-2" class="headerlink" title="功能说明"></a>功能说明</h2><p>让当前执行的线 程休眠n毫秒， 休眠时让出 cpu 的时间片给其它 线程</p><h2 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h2><p>​        1、调用 sleep 会让当前线程从 Running  进入 Timed Waiting 状态（阻塞）</p><p>​        2、其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException </p><p>​        3、睡眠结束后的线程未必会立刻得到执行</p><p>​        4、建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p><h2 id="与wait区别"><a href="#与wait区别" class="headerlink" title="与wait区别"></a>与wait区别</h2><p>1、sleep方法属于Thread，而wait方法属于Object类<br>2、调用sleep的过程中，线程不会释放对象锁；而调用wait方法的时候，线程会放弃对象锁，进入等待此对象的等待对象池，只有此对象调用notify方法后本线程才进入对象锁定池准备获取对象锁进入运行状态<br>3、sleep（long）会导致线程进入TIMED-WATING状态，而wait（）方法会导致当前线程进入WATING状态</p><h1 id="4、interrupt"><a href="#4、interrupt" class="headerlink" title="4、interrupt()"></a>4、interrupt()</h1><h2 id="功能说明-3"><a href="#功能说明-3" class="headerlink" title="功能说明"></a>功能说明</h2><p>打断线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标示位。这个线程本身并不会因此而改变状态（如阻塞，终止等）。</p><h2 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h2><p>如果被打断线程正在 sleep，wait，join 会导致被打断 的线程抛出 InterruptedException，并清除打断标记 ，使isInterrupted为false，如果这时我们通过代码捕获该异常，然后break跳出循环状态，然后让我们有机会结束这个线程的执行；如果打断的正在运行的线程，则会设置 打断标记 ；park 的线程被打断，也会设置 打断标记<br>值得注意的是：<br>1、调用该方法并不会终止一个正在运行（Running状态）的线程，仅仅改变内部维护的中断标示位而已<br>2、若调用sleep方法是线程处于TIMED-WATING状态，这时调用interrupt方法，会抛出InterruptedException，从而使线程提前结束TIIMED-WATING状态<br>3、通常很多人认为只要调用 interrupt 方法线程就会结束，实 际上是错的， 一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法</p><p>4、许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异<br>常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。</p><p>5、中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止 一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以 根据 thread.isInterrupted()的值来优雅的终止线程。</p><h2 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h2><h3 id="打断sleep，wait，join线程"><a href="#打断sleep，wait，join线程" class="headerlink" title="打断sleep，wait，join线程"></a>打断sleep，wait，join线程</h3><p>以打断sleep线程为例，会清空打断状态</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>     Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">" 打断状态: {}"</span><span class="token punctuation">,</span> t1<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出</p><pre><code>java.lang.InterruptedException: sleep interrupted    at java.lang.Thread.sleep(Native Method)    at java.lang.Thread.sleep(Thread.java:340)    at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)    at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)    at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)     at java.lang.Thread.run(Thread.java:745)21:18:10.374 [main] c.TestInterrupt -  打断状态: false</code></pre><p>清除打断标记 ，使isInterrupted为false；</p><h3 id="打断正在运行的线程"><a href="#打断正在运行的线程" class="headerlink" title="打断正在运行的线程"></a>打断正在运行的线程</h3><p>不会清空打断状态</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>     Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> current<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span> <span class="token punctuation">{</span>                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">" 打断状态: {}"</span><span class="token punctuation">,</span> interrupted<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     t2<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出</p><pre><code>20:57:37.964 [t2] c.TestInterrupt -  打断状态: true</code></pre><h3 id="打断park线程"><a href="#打断park线程" class="headerlink" title="打断park线程"></a>打断park线程</h3><p>不会清空打断状态</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"park..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"unpark..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"打断状态：{}"</span><span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     t1<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出</p><pre><code>21:11:52.795 [t1] c.TestInterrupt - park... 21:11:53.295 [t1] c.TestInterrupt - unpark... 21:11:53.295 [t1] c.TestInterrupt - 打断状态：true</code></pre><h1 id="5、interrupted"><a href="#5、interrupted" class="headerlink" title="5、interrupted()"></a>5、interrupted()</h1><p>判断当前线程是否被打断，会清楚打断标记</p><h1 id="6、isInterrupted"><a href="#6、isInterrupted" class="headerlink" title="6、isInterrupted()"></a>6、isInterrupted()</h1><p>判断是否被打断，不会被清除</p><h1 id="7、yield"><a href="#7、yield" class="headerlink" title="7、yield()"></a>7、yield()</h1><h2 id="功能说明-4"><a href="#功能说明-4" class="headerlink" title="功能说明"></a>功能说明</h2><p>提示线程调度器 让出当前线程对 CPU的使用</p><p>主要是为了测试和调试</p><p>yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下，<br>优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是绝对的，有的操作系统对 线程优先级并不敏感。</p><h2 id="注意-4"><a href="#注意-4" class="headerlink" title="注意"></a>注意</h2><p>​        1、调用 yield 会让当前线程从 Running 进入 Runnable  就绪状态，然后调度执行其它线程 </p><p>​        2、具体的实现依赖于操作系统的任务调度器</p><h1 id="8、join"><a href="#8、join" class="headerlink" title="8、join()"></a>8、join()</h1><h2 id="功能说明-5"><a href="#功能说明-5" class="headerlink" title="功能说明"></a>功能说明</h2><p>等待线程运行结束</p><p>join()方法使调用该方法的线程在此之前执行完毕，也就是等待该方法的线程执行完毕后再往下继续执行。注意该方法也需要捕捉异常。</p><p>在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>调用者轮询检查线程alive状态</p><p>t1.join();</p><p>等价于</p><pre class=" language-java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>t1<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束 </span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        t1<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="为什么要用join方法"><a href="#为什么要用join方法" class="headerlink" title="为什么要用join方法"></a>为什么要用join方法</h2><p>很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要在子线程结束后再结束，这时候就要用到 join() 方法。 </p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"线程运行开始!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread6 thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  thread1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"线程 B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          thread1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这时 thread1 执行完毕之后才能执行主线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="9、join-long-n"><a href="#9、join-long-n" class="headerlink" title="9、join(long n)"></a>9、join(long n)</h1><p>等待线程运行结束，最多等待n秒</p><h1 id="10、getId"><a href="#10、getId" class="headerlink" title="10、getId()"></a>10、getId()</h1><p>获取线程长整型的id（id唯一）</p><h1 id="11、getName"><a href="#11、getName" class="headerlink" title="11、getName()"></a>11、getName()</h1><p>获取线程名</p><h1 id="12、setName-String"><a href="#12、setName-String" class="headerlink" title="12、setName(String)"></a>12、setName(String)</h1><p>修改线程名</p><h1 id="13、getPriority"><a href="#13、getPriority" class="headerlink" title="13、getPriority()"></a>13、getPriority()</h1><p>获取线程优先级</p><h1 id="14、setPriority"><a href="#14、setPriority" class="headerlink" title="14、setPriority()"></a>14、setPriority()</h1><p>修改线程优先级</p><p>java中规定线程优先级是1~10 的整数，较大的优先级 能提高该线程被 CPU 调度的机率</p><h1 id="15、getState"><a href="#15、getState" class="headerlink" title="15、getState()"></a>15、getState()</h1><p>获取线程状态</p><p>Java 中线程状态是用 6 个 enum 表示，分别为：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED</p><h1 id="16、currentThread"><a href="#16、currentThread" class="headerlink" title="16、currentThread()"></a>16、currentThread()</h1><p>获取当前正在执行的线程</p><h1 id="17、补充：wait-和notify-、notifyAll"><a href="#17、补充：wait-和notify-、notifyAll" class="headerlink" title="17、补充：wait()和notify()、notifyAll()"></a>17、补充：<strong>wait()和notify()、notifyAll()</strong></h1><h2 id="功能说明-6"><a href="#功能说明-6" class="headerlink" title="功能说明"></a>功能说明</h2><p>这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用。synchronized关键字用于保护共享数据，阻止其他线程对共享数据的存取，但是这样程序的流程就很不灵活了，如何才能在当前线程还没退出synchronized数据块时让其他线程也有机会访问共享数据呢？此时就用这三个方法来灵活控制。</p><p>wait()方法使当前线程暂停执行并释放对象锁标示，让其他线程可以进入synchronized数据块，当前线程被放入对象等待池中。<br>调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用 wait()方法后，会释放对象的锁。因此，wait 方法一般用在同步方法或同步代码块中。</p><p>当调用notify()方法后，将从对象的等待池中移走一个<strong>任意的线程</strong>并放到锁标志等待池中，只有锁标志等待池中线程能够获取锁标志，即唤醒在此对象监视器上等待的单个线程；如果锁标志等待池中没有线程，则notify()不起作用。</p><p>notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。</p><p><strong>注意 这三个方法都是java.lang.Object的方法。</strong></p><h2 id="wait-notify原理"><a href="#wait-notify原理" class="headerlink" title="wait notify原理"></a>wait notify原理</h2><p><img src="img%5Cwait%E5%92%8Cnotify%E5%8E%9F%E7%90%86.PNG" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 并发与多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存区域详解</title>
      <link href="/2019/07/04/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2019/07/04/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>众所周知，Java虚拟机有自动内存管理机制，在这个机制下，我们不再 不需要像C++/C程序开发员这样为每一个new操作去写其对应的delete/free操作，这样就不容易出现内存泄漏和溢出2方面的问题。因为我们把内存控制权力交给了虚拟机，如果出现内存泄漏和溢出方面的问题，排查错误就必须要了解虚拟机内部是怎样使用内存的。</p><p>下图是JDK8之后的JVM内存布局。</p><p><img src="img/jvm%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.PNG" alt=""></p><p>（引自<a href="https://www.cnblogs.com/czwbig/p/11127124.html）" target="_blank" rel="noopener">https://www.cnblogs.com/czwbig/p/11127124.html）</a></p><h2 id="1、私有or共享？"><a href="#1、私有or共享？" class="headerlink" title="1、私有or共享？"></a>1、私有or共享？</h2><p>按线程是否私有，我们可以将其分为：</p><p>线程私有：程序计数器、虚拟机栈、本地方法栈</p><p>线程共享：堆、方法区、直接内存（非运行时数据区的一部分）</p><h2 id="2、线程和进程"><a href="#2、线程和进程" class="headerlink" title="2、线程和进程"></a>2、线程和进程</h2><p>​        我们先来谈谈什么是线程，线程是进程中的一个实体，线程本身是不会独立存在的。进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径，一个进程至少有一个线程，进程中的多个线程共享进程的资源。</p><p>​        操作系统在分配资源时是把资源分配给进程的，但是CPU资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以<strong>线程是CPU分配的基本单位</strong>。</p><p>​        我们在Java中启动的main函数其实就是启动了一个JVM的进程，而main函数所在的线程就是这个进程中的一个线程，也称之为主线程。</p><p>​        一个进程中有多个线程，多个线程共享进程的堆和方法区资源，所以说他们是线程共享的，而每个线程又有自己的程序计数器和栈区域。</p><h2 id="3、各区域介绍"><a href="#3、各区域介绍" class="headerlink" title="3、各区域介绍"></a>3、各区域介绍</h2><h3 id="3-1、程序计数器"><a href="#3-1、程序计数器" class="headerlink" title="3.1、程序计数器"></a>3.1、程序计数器</h3><p>​        程序计数器是一块较小的内存区域，用来记录线程当前要执行的指令地址。</p><p>​        我们在前面提到程序计数器是线程私有的，那为什么要将其设计为私有呢？在上一节我们介绍到线程是占用CPu执行的基本单位，而CPU一般是使用时间片轮转方式（这不禁让我想起老式的电影放映机，就是为了节约胶卷也采用这种类似的轮转方式，间接提高帧率），让线程轮询占用的，所以当前线程CPU时间片用完后要让出CPU，等下次轮到自己的时候再执行（如果执行的是native方法，pc计数器记录是是undefined地址，只有执行的是Java代码时，计数器记录的才是下一条指令的地址）。那么如何知道之前程序执行到哪了呢？这就是程序计数器的作用力，计数器记录了该线程让出CPU时的执行地址，待再分配到时间片时线程就可以从私有的计数器指定地址继续执行。</p><p>​        程序计数器私有使得每个线程都有一个独立的程序计数器，各计数器之间互不影响，独立存储。</p><p>​        程序计数器的作用除了在多线程的情况下记录当前线程执行的位置，从而切换时能够知道上次运行到哪外，还有另个作用：字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</p><p><code>*注</code></p><p>关于其生命周期：随线程创建而创建，随线程的结束而死亡。</p><p><img src="img%5Cyoujumpijump.jpg" alt=""></p><h3 id="3-2Java虚拟机栈"><a href="#3-2Java虚拟机栈" class="headerlink" title="3.2Java虚拟机栈"></a>3.2Java虚拟机栈</h3><p>​        我们常说的，Java内存可以粗糙的区分为堆内存和栈内存，其中栈就是我们要说的虚拟机栈。</p><p>和计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。</p><ul><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><p>​        虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表（存放了编译器可知的各种数据类型：boolean、byte、char、short、int、float、long、double、对象引用）、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>在活动线程中，只有位于栈顶的 栈帧才是有效的，称之为当前栈帧。当前栈帧正在执行的方法称为当前方法，栈帧是方法运行的基本结构。在执行引擎运行时，所有指令都只能针对当前栈帧进行操作。</p><p>​        每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。Java方法有两种返回方式：</p><p>return语句或抛出异常。不管哪种方式都会导致栈帧被弹出。</p><h4 id="1-局部变量表"><a href="#1-局部变量表" class="headerlink" title="1. 局部变量表"></a>1. 局部变量表</h4><p>局部变量表是存放方法参数和局部变量的区域。 局部变量没有准备阶段， 必须显式初始化。如果是非静态方法，<strong>则在 index[0] 位置上存储的是方法所属对象的实例引用</strong>，一个引用变量占 4 个字节，随后存储的是参数和局部变量。字节码指令中的 STORE 指令就是将操作栈中计算完成的局部变呈写回局部变量表的存储空间内。</p><p>虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展），如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。</p><h4 id="2-操作栈"><a href="#2-操作栈" class="headerlink" title="2. 操作栈"></a>2. 操作栈</h4><p>操作栈是个初始状态为空的桶式结构栈。在方法执行过程中， 会有各种指令往<br>栈中写入和提取信息。JVM 的执行引擎是基于栈的执行引擎， 其中的栈指的就是操<br>作栈。字节码指令集的定义都是基于栈类型的，栈的深度在方法元信息的 stack 属性中。</p><p><strong>i++ 和 ++i 的区别：</strong></p><ol><li><p>i++：从局部变量表取出 i 并压入操作栈，然后对局部变量表中的 i 自增 1，将操作栈栈顶值取出使用，最后，使用栈顶值更新局部变量表，如此线程从操作栈读到的是自增之前的值。</p></li><li><p>++i：先对局部变量表的 i 自增 1，然后取出并压入操作栈，再将操作栈栈顶值取出使用，最后，使用栈顶值更新局部变量表，线程从操作栈读到的是自增之后的值。</p><p>i++ 不是原子操作，即使使用 volatile 修饰也不是线程安全，就是因为，可能 i 被从局部变量表（内存）取出，压入操作栈（寄存器），操作栈中自增，使用栈顶值更新局部变量表（寄存器更新写入内存），其中分为 3 步，volatile 保证可见性，保证每次从局部变量表读取的都是最新的值，但可能这 3 步可能被另一个线程的 3 步打断，产生数据互相覆盖问题，从而导致 i 的值比预期的小。</p></li></ol><p>如我们可以从字节码的角度分析i++：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span> <span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    i<span class="token operator">=</span>i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>编译后的字节码如下：</p><p><img src="img%5Ci++%E5%AD%97%E8%8A%82%E7%A0%81.PNG" alt=""></p><p><img src="img%5C%E5%AD%97%E8%8A%82%E7%A0%81.PNG" alt=""></p><h4 id="3-动态链接"><a href="#3-动态链接" class="headerlink" title="3. 动态链接"></a>3. 动态链接</h4><p>每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接。</p><h4 id="4-方法返回地址"><a href="#4-方法返回地址" class="headerlink" title="4.方法返回地址"></a>4.方法返回地址</h4><p>方法执行时有两种退出情况：</p><ol><li>正常退出，即正常执行到任何方法的返回字节码指令，如 RETURN、IRETURN、ARETURN 等；</li><li>异常退出。</li></ol><p>无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：</p><ol><li>返回值压入上层调用栈帧。</li><li>异常信息抛给能够处理的栈帧。</li><li>PC计数器指向方法调用后的下一条指令。</li></ol><h3 id="3-3、本地方法栈"><a href="#3-3、本地方法栈" class="headerlink" title="3.3、本地方法栈"></a>3.3、本地方法栈</h3><p>​        本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</p><p>​        本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该方法的局部变量表、操作数栈、动态链接和出口信息。</p><p>​        本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h3 id="3-4、堆"><a href="#3-4、堆" class="headerlink" title="3.4、堆"></a>3.4、堆</h3><p>​        对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。</p><p>​        Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”，由于现在收集器基本都是采用的<strong>分代收集算法</strong>，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。如果<strong>从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区</strong>（Thread Local Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p><h3 id="3-5、方法区"><a href="#3-5、方法区" class="headerlink" title="3.5、方法区"></a>3.5、方法区</h3><p>方法区与堆一样，是各个线程共享的内存区域，它<strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的是与堆区分开来。</p><h3 id="3-6、运行时常量池"><a href="#3-6、运行时常量池" class="headerlink" title="3.6、运行时常量池"></a>3.6、运行时常量池</h3><p>​        <strong>运行时常量池（Runtime Constant Pool）是方法区的一部分</strong>。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>一般来说，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p><p>运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><h3 id="3-7、直接内存"><a href="#3-7、直接内存" class="headerlink" title="3.7、直接内存"></a>3.7、直接内存</h3><p>​        <strong>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域</strong>。</p><p>​        在 JDK 1.4 中新加入了 NIO，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，<strong>因为避免了在 Java 堆和 Native 堆中来回复制数据</strong>。</p><p>​        显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括 RAM 以及 SWAP 区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置 -Xmx 等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError 异常。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法</title>
      <link href="/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在Java 中，我们常用的查找有四种: 1) 顺序(线性)查找<br>2) 二分查找/折半查找<br>3) 插值查找<br>4) 斐波那契查找</p><h1 id="一、线性查找"><a href="#一、线性查找" class="headerlink" title="一、线性查找"></a>一、线性查找</h1><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>jc<span class="token punctuation">.</span>demo1<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SeqSearch</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">41</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span><span class="token function">seqSearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"没有该数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"该数的下标为："</span><span class="token operator">+</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">seqSearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="二、二分查找"><a href="#二、二分查找" class="headerlink" title="二、二分查找"></a>二、二分查找</h1><h2 id="1、初级"><a href="#1、初级" class="headerlink" title="1、初级"></a>1、初级</h2><p><img src="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8E%9F%E7%90%86.png" alt="二分查找原理"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>jc<span class="token punctuation">.</span>demo1<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinarySearch</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token number">54</span><span class="token punctuation">,</span><span class="token number">67</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span><span class="token function">binarySearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">54</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"没有该数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"该数的下标为："</span><span class="token operator">+</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//二分法的前提是数组本身是有序的</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//当left>right时，说明递归整个数组，但没有找到</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token operator">></span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//向右递归查找</span>      <span class="token keyword">return</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//向左递归查找</span>      <span class="token keyword">return</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> mid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="2、优化"><a href="#2、优化" class="headerlink" title="2、优化"></a>2、优化</h2><p>补充： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，</p><p>有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000</p><p>思路分析</p><p>1、在找到 mid 索引值，不要马上返回</p><p>2、向 mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList </p><p>3、向 mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList </p><p>4、将 Arraylist 返回</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>jc<span class="token punctuation">.</span>demo1<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinarySearch</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">1234</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> resIndexList <span class="token operator">=</span><span class="token function">binarySearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>resIndexList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"没有该数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"该数的下标为："</span><span class="token operator">+</span>resIndexList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//二分法的前提是数组本身是有序的</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//当left>right时，说明递归整个数组，但没有找到</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回一个空的</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token operator">></span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//向右递归查找</span>      <span class="token keyword">return</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//向左递归查找</span>      <span class="token keyword">return</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>      List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> resIndexlist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//向 mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span>      <span class="token keyword">int</span> temp<span class="token operator">=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span>arr<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token operator">!=</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//退出</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//否则，就将temp放入resIndexlist</span>        resIndexlist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        temp<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//temp左移</span>      <span class="token punctuation">}</span>      resIndexlist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把mid的下标加进来</span>      <span class="token comment" spellcheck="true">//向 mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span>      temp<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">></span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span>arr<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token operator">!=</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        resIndexlist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        temp<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> resIndexlist<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="三、插值查找"><a href="#三、插值查找" class="headerlink" title="三、插值查找"></a>三、插值查找</h1><p>1) 插值查找原理介绍:<br>插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid 处开始查找。<br>2) 将折半查找中的求 mid 索引的公式 , low 表示左边索引 left, high 表示右边索引 right. key 就是前面我们讲的 target</p><p><img src="%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86.png" alt=""></p><p>3) int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;/<em>插值索引</em>/<br>对应前面的代码公式：<br>int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])<br>4) 举例说明插值查找算法 1-100 的数组</p><p><img src="%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%862.png" alt=""></p><p>插值算法也要求被查找数组有序</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>jc<span class="token punctuation">.</span>demo1<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsertValueSearch</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//创建一个1-100的数组</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">insertValueSearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">78</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"该数下标为："</span><span class="token operator">+</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">insertValueSearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"插值查找被调用~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//注意：target &lt; arr[0] 和 target > arr[arr.length - 1] 必须需要</span>    <span class="token comment" spellcheck="true">// 否则我们得到的 mid 可能越界</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">></span>right<span class="token operator">||</span>target<span class="token operator">&lt;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">||</span>target<span class="token operator">></span>arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 求出 mid, 自适应</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>target <span class="token operator">-</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">-</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> midVal <span class="token operator">=</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">></span> midVal<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 说明应该向右边递归</span>      <span class="token keyword">return</span> <span class="token function">insertValueSearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> midVal<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 说明向左递归查找</span>      <span class="token keyword">return</span> <span class="token function">insertValueSearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> mid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出</p><pre><code>插值查找被调用~该数下标为：77</code></pre><p>只递归一次就找到了</p><p>同样的arr，同样查找78，使用二分查找：</p><pre><code>二分查找被调用~二分查找被调用~二分查找被调用~二分查找被调用~二分查找被调用~该数的下标为：[77]</code></pre><p>1) 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快. </p><p>2) 关键字分布不均匀的情况下，该方法不一定比折半查找要好</p><h1 id="四、斐波那契查找"><a href="#四、斐波那契查找" class="headerlink" title="四、斐波那契查找"></a>四、斐波那契查找</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>1) 黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位 数字的近似值是 0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神<br>奇的数字，会带来意向不大的效果。</p><p>2) 斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值 0.618</p><p>该查找算法要求被查找数组为有序</p><h2 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h2><p>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位 于黄金分割点附近，即 mid=low+F(k-1)-1（F 代表斐波那契数列），如下图所示</p><p><img src="%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE%E5%8E%9F%E7%90%86.png" alt=""></p><p>对 F(k-1)-1 的理解：</p><p>1) 由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：只要顺序表的长度为 F[k]-1，则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段，即如上图所示。从而中间位置为 mid=low+F(k-1)-1</p><p>2) 类似的，每一子段也可以用相同的方式分割</p><p>3) 但顺序表长度 n 不一定刚好等于 F[k]-1，所以需要将原来的顺序表长度 n 增加至 F[k]-1。这里的 k 值只要能使<br>得 F[k]-1 恰好大于或等于 n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从 n+1 到 F[k]-1 位置）， 都赋为 n 位置的值即可。<br>while(n&gt;fib(k)-1)<br>k++;</p><h2 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>jc<span class="token punctuation">.</span>demo1<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FibonacciSearch</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> maxSize<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">89</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">1234</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">fibSearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"该数不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"该数的下表为："</span><span class="token operator">+</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//因为后面我们 mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列 //非递归方法得到一个斐波那契数列</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>maxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> f<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//编写斐波那契查找算法</span><span class="token comment" spellcheck="true">//使用非递归的方式编写算法</span>  <span class="token comment" spellcheck="true">/**   *   * @param a 数组   * @param key 我们需要查找的关键码(值) * @return 返回对应的下标，如果没有-1   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">fibSearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> high <span class="token operator">=</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//表示斐波那契分割数值的下标</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//存放mid值</span>    <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//获取到斐波那契数列</span>    <span class="token comment" spellcheck="true">//获取到斐波那契分割数值的下标</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>high <span class="token operator">></span> f<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span>    <span class="token comment" spellcheck="true">//不足的部分会使用0填充</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//实际上需求使用a数组最后的数填充 temp</span>    <span class="token comment" spellcheck="true">//举例:</span>    <span class="token comment" spellcheck="true">//temp = {1,8, 10, 89, 1000, 1234, 0, 0}  => {1,8, 10, 89, 1000, 1234, 1234, 1234,}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> temp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使用while来循环处理，找到我们的数 key</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 只要这个条件满足，就可以找</span>      mid <span class="token operator">=</span> low <span class="token operator">+</span> f<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&lt;</span> temp<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//我们应该继续向数组的前面查找(左边)</span>        high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//为甚是 k--</span>        <span class="token comment" spellcheck="true">//说明</span>        <span class="token comment" spellcheck="true">//1. 全部元素 = 前面的元素 + 后边元素</span>        <span class="token comment" spellcheck="true">//2. f[k] = f[k-1] + f[k-2]</span>        <span class="token comment" spellcheck="true">//因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]</span>        <span class="token comment" spellcheck="true">//即 在 f[k-1] 的前面继续查找 k--</span>        <span class="token comment" spellcheck="true">//即下次循环 mid = f[k-1-1]-1</span>        k<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> key <span class="token operator">></span> temp<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 我们应该继续向数组的后面查找(右边)</span>        low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//为什么是k -=2</span>        <span class="token comment" spellcheck="true">//说明</span>        <span class="token comment" spellcheck="true">//1. 全部元素 = 前面的元素 + 后边元素</span>        <span class="token comment" spellcheck="true">//2. f[k] = f[k-1] + f[k-2]</span>        <span class="token comment" spellcheck="true">//3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]</span>        <span class="token comment" spellcheck="true">//4. 即在f[k-2] 的前面进行查找 k -=2</span>        <span class="token comment" spellcheck="true">//5. 即下次循环 mid = f[k - 1 - 2] - 1</span>        k <span class="token operator">-=</span> <span class="token number">2</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//找到</span>        <span class="token comment" spellcheck="true">//需要确定，返回的是哪个下标</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>mid <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> high<span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各排序算法介绍、图解说明、代码详解、复杂度分析、选择</title>
      <link href="/2019/05/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%90%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%E3%80%81%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%E3%80%81%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%E3%80%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E3%80%81%E9%80%89%E6%8B%A9/%E5%90%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%E3%80%81%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%E3%80%81%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%E3%80%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E3%80%81%E9%80%89%E6%8B%A9/"/>
      <url>/2019/05/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%90%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%E3%80%81%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%E3%80%81%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%E3%80%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E3%80%81%E9%80%89%E6%8B%A9/%E5%90%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%E3%80%81%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%E3%80%81%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%E3%80%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E3%80%81%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="一、排序的分类："><a href="#一、排序的分类：" class="headerlink" title="一、排序的分类："></a>一、排序的分类：</h1><p>1) 内部排序:<br>指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。<br>2) 外部排序法：<br>数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。 </p><p>常见的排序算法分类：</p><p><img src="img%5C%E5%B0%9A%E7%A1%85%E8%B0%B7_%E9%9F%A9%E9%A1%BA%E5%B9%B3_%E5%9B%BE%E8%A7%A3Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95!@#$%%5E&_(" alt="">_ +.png)</p><p>我们这里主要介绍内排序的多种方法。</p><h1 id="二、内排序算法性能主要影响因素"><a href="#二、内排序算法性能主要影响因素" class="headerlink" title="二、内排序算法性能主要影响因素"></a>二、内排序算法性能主要影响因素</h1><p>对于内排序而言，排序算法的性能主要受3个方面影响：</p><h2 id="1、时间性能"><a href="#1、时间性能" class="headerlink" title="1、时间性能"></a>1、时间性能</h2><p>排序算法的时间开销是衡量它好坏的最重要的标志。而内排序主要进行两种操作：比较和移动。所以我们应该尽可能少的关键字比较次数和尽可能少的记录移动次数。</p><h2 id="2、辅助空间（空间复杂度）"><a href="#2、辅助空间（空间复杂度）" class="headerlink" title="2、辅助空间（空间复杂度）"></a>2、辅助空间（空间复杂度）</h2><p>辅助空间是除了存放排序所占用的存储空间外，执行算法所需要的其他存储空间。</p><h2 id="3、算法的复杂性"><a href="#3、算法的复杂性" class="headerlink" title="3、算法的复杂性"></a>3、算法的复杂性</h2><p>这里指的是算法本身的复杂度，而不是指算法的时间复杂度。显然，算法过于复杂也会影响排序的性能。</p><h1 id="三、各排序算法详解"><a href="#三、各排序算法详解" class="headerlink" title="三、各排序算法详解"></a>三、各排序算法详解</h1><h2 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h2><h3 id="1）简介"><a href="#1）简介" class="headerlink" title="1）简介"></a>1）简介</h3><p>冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。</p><h3 id="2-初级冒泡排序"><a href="#2-初级冒泡排序" class="headerlink" title="2)初级冒泡排序"></a>2)初级冒泡排序</h3><h4 id="a、图解"><a href="#a、图解" class="headerlink" title="a、图解"></a>a、图解</h4><p><img src="img%5C%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%88%9D%E7%BA%A7%E5%9B%BE%E7%A4%BA.PNG" alt=""></p><p>（摘自《大话数据结构》）</p><h4 id="b、代码实现"><a href="#b、代码实现" class="headerlink" title="b、代码实现"></a>b、代码实现</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>jc<span class="token punctuation">.</span>demo1<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token function">BubbleSort1</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">BubbleSort1</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> temp<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          temp<span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>          arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>排序前[9, 1, 5, 8, 3, 7, 4, 6, 2]排序后[1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><p>这个严格意义上不算标准的冒泡排序，因为他不满足两两比较相邻记录，他更应该是最最简单的交换排序而已。</p><h3 id="3）中阶冒泡排序"><a href="#3）中阶冒泡排序" class="headerlink" title="3）中阶冒泡排序"></a>3）中阶冒泡排序</h3><h4 id="a、图解-1"><a href="#a、图解-1" class="headerlink" title="a、图解"></a>a、图解</h4><p><img src="img%5C%E5%86%92%E6%B3%A1%E4%B8%AD%E9%98%B6.PNG" alt=""></p><p>（摘自《大话数据结构》）</p><h4 id="b、代码实现-1"><a href="#b、代码实现-1" class="headerlink" title="b、代码实现"></a>b、代码实现</h4><p>从后往前循环</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token function">BubbleSort1</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">BubbleSort2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> temp<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">>=</span>i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          temp<span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>          arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>输出一致 </p><h3 id="4）高阶冒泡排序"><a href="#4）高阶冒泡排序" class="headerlink" title="4）高阶冒泡排序"></a>4）高阶冒泡排序</h3><h4 id="a、图解-2"><a href="#a、图解-2" class="headerlink" title="a、图解"></a>a、图解</h4><p>当i=1时，交换了2和1，此时排序已经有序了，但是算法还是将i=2到9和每个循环中的j循环了一遍，我们可以设置医德标志flag判断元素是否进行过交换，如果没有交换了，就结束循环，减少不必要的比较。</p><p><img src="img%5C%E5%86%92%E6%B3%A1%E9%AB%98%E7%BA%A7%E6%81%A9.PNG" alt=""></p><p>（摘自《大话数据结构》）</p><h4 id="b、代码实现-2"><a href="#b、代码实现-2" class="headerlink" title="b、代码实现"></a>b、代码实现</h4><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">BubbleSort3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> temp<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> flag<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>flag<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">>=</span>i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          temp<span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>          arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>          flag<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有交换则改为true</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//在这一趟中。一次交换都没有发生</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>      flag<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//重置flag，进行下一次判断</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><h3 id="5）时间复杂度分析"><a href="#5）时间复杂度分析" class="headerlink" title="5）时间复杂度分析"></a>5）时间复杂度分析</h3><p>最好情况下，即本身是有序的，那就是n-1次的比较，即O（n）</p><h2 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h2><h3 id="1）简介-1"><a href="#1）简介-1" class="headerlink" title="1）简介"></a>1）简介</h3><p>选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从 arr[0]<del>arr[n-1]中选取最小值， 与 arr[0]交换，第二次从 arr[1]</del>arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]<del>arr[n-1]中选取最小值，与arr[2] 交换，…，第 i 次从 arr[i-1]</del>arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从arr[n-2]~arr[n-1]中选取最小值， 与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。</p><p>即通过n-1次关键字的比较，从aar[i]到arr[n-1]中选出最小值，并和arr[i]交换。</p><h3 id="2）图解"><a href="#2）图解" class="headerlink" title="2）图解"></a>2）图解</h3><p><img src="img%5C%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.PNG" alt=""></p><p>（摘自《大话数据结构》）</p><h3 id="3）代码实现"><a href="#3）代码实现" class="headerlink" title="3）代码实现"></a>3）代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>jc<span class="token punctuation">.</span>demo1<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelectSort</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr3 <span class="token operator">=</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> minIndex<span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录aar[i]到arr[n-1]中的最小值的下标</span>      <span class="token keyword">int</span> min<span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录aar[i]到arr[n-1]中的最小值</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>min<span class="token operator">></span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//说明假定的最小值并非是最小</span>          min<span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>          minIndex<span class="token operator">=</span>j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>minIndex<span class="token operator">!=</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//如果minIndex不是原本的i，说明最小的那个的下标应该是 minIndex，替换</span>        arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4-时间复杂度分析"><a href="#4-时间复杂度分析" class="headerlink" title="4)时间复杂度分析"></a>4)时间复杂度分析</h3><p>O（n^2）</p><h2 id="3、直接插入排序法"><a href="#3、直接插入排序法" class="headerlink" title="3、直接插入排序法"></a>3、直接插入排序法</h2><h3 id="1）简介-2"><a href="#1）简介-2" class="headerlink" title="1）简介"></a>1）简介</h3><p>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。</p><p>基本思想是：把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有 序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 </p><h3 id="2）图解-1"><a href="#2）图解-1" class="headerlink" title="2）图解"></a>2）图解</h3><p><img src="img%5C%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%B3%95%E6%8E%92%E5%BA%8F" alt=""></p><h3 id="3）代码实现-1"><a href="#3）代码实现-1" class="headerlink" title="3）代码实现"></a>3）代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>jc<span class="token punctuation">.</span>demo1<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsertSort</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr3 <span class="token operator">=</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> k<span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置哨兵用于比较</span>      <span class="token keyword">int</span> j<span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>k<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录后移，给a[i]腾位置</span>      <span class="token punctuation">}</span>      arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>k<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//插入到正确的位置</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4-时间复杂度分析-1"><a href="#4-时间复杂度分析-1" class="headerlink" title="4)时间复杂度分析"></a>4)时间复杂度分析</h3><p>O（n^2），但比冒泡和简单选择排序性能要好些</p><h2 id="4、希尔排序法"><a href="#4、希尔排序法" class="headerlink" title="4、希尔排序法"></a>4、希尔排序法</h2><h3 id="1）简介-3"><a href="#1）简介-3" class="headerlink" title="1）简介"></a>1）简介</h3><p>我们看简单的插入排序可能存在的问题.<br>数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是： {2,3,4,5,6,6}<br>{2,3,4,5,5,6}<br>{2,3,4,4,5,6}<br>{2,3,3,4,5,6}<br>{2,2,3,4,5,6}<br>{1,2,3,4,5,6}<br>结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.</p><p>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。</p><p>希尔排序的思想是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含 的关键词越来越多，当增量减至1 时，整个文件恰被分成一组，算法便终止</p><h3 id="2）图解-2"><a href="#2）图解-2" class="headerlink" title="2）图解"></a>2）图解</h3><p><img src="img%5C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" alt=""></p><p><img src="img%5C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F2" alt=""></p><h3 id="3）代码实现-2"><a href="#3）代码实现-2" class="headerlink" title="3）代码实现"></a>3）代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>jc<span class="token punctuation">.</span>demo1<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShellSort</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr3 <span class="token operator">=</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 遍历各组中所有的元素(共 gap 组，每组有个元素), 步长 gap</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> gap<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">-=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 如果当前元素大于加上步长后的那个元素，说明交换</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4）时间复杂度分析"><a href="#4）时间复杂度分析" class="headerlink" title="4）时间复杂度分析"></a>4）时间复杂度分析</h3><p>O（n^3/2）好于之前的O（n^2）</p><h2 id="5、快速排序"><a href="#5、快速排序" class="headerlink" title="5、快速排序"></a>5、快速排序</h2><h3 id="1）简介-4"><a href="#1）简介-4" class="headerlink" title="1）简介"></a>1）简介</h3><p>快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两<br>部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排 序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p><p>快速排序的原理：选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。一次循环：从后往前比较，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有<br>继续比较下一个，直到找到第一个比基准值小的值才交换。找到这个值之后，又从前往后开始比较，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的值才交换。直到从前往后的比较索引&gt;从后往前比较的索引，结束第一次循环，此时，对于基准值来说，左右两边就是有序的了。</p><h3 id="2）图解-3"><a href="#2）图解-3" class="headerlink" title="2）图解"></a>2）图解</h3><p>方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从<strong>右</strong>往<strong>左</strong>找一个小于6的数，再从<strong>左</strong>往<strong>右</strong>找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。</p><p><img src="img%5C%E5%BF%AB%E6%8E%921" alt="这里写图片描述"><br>首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（请自己想一想为什么）。哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。<br><img src="img%5C%E5%BF%AB%E6%8E%922" alt="这里写图片描述"></p><p>现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下：</p><p>6 1 2 <strong>5</strong> 9 3 4 <strong>7</strong> 10 8<br><img src="img%5C%E5%BF%AB%E6%8E%923" alt="这里写图片描述"><br><img src="img%5C%E5%BF%AB%E6%8E%924" alt="这里写图片描述"><br>到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下：</p><p>6 1 2 5 <strong>4</strong> 3 <strong>9</strong> 7 10 8</p><p>第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下：</p><p><strong>3</strong> 1 2 5 4 <strong>6</strong> 9 7 10 8</p><p><img src="img%5C%E5%BF%AB%E6%8E%925" alt="这里写图片描述"><br><img src="img%5C%E5%BF%AB%E6%8E%926" alt="这里写图片描述"><br><img src="img%5C%E5%BF%AB%E6%8E%927" alt="这里写图片描述"></p><p>到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。</p><p>OK，解释完毕。现在基准数6已经归位，它正好处在序列的第6位。此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。</p><p>左边的序列是“3 1 2 5 4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3。好了开始动笔吧</p><p>如果你模拟的没有错，调整完毕之后的序列的顺序应该是：</p><p>2 1 <strong>3</strong> 5 4</p><p>OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下：</p><p>1 2 3 4 5 6 9 7 10 8</p><p>对于序列“9 7 10 8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下</p><p>1 2 3 4 5 6 7 8 9 10</p><p>到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。<br><img src="img%5C%E5%BF%AB%E6%8E%928" alt="这里写图片描述"></p><p>这是为什么呢？</p><p>快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。其实快速排序是基于一种叫做“二分”的思想。</p><h3 id="3）代码实现-3"><a href="#3）代码实现-3" class="headerlink" title="3）代码实现"></a>3）代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>jc<span class="token punctuation">.</span>demo1<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr3 <span class="token operator">=</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果left等于right，即数组只有一个元素，直接返回</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">>=</span>high<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> i<span class="token operator">=</span>low<span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token operator">=</span>high<span class="token punctuation">;</span>    <span class="token keyword">int</span> key<span class="token operator">=</span>arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取最左边的为基准点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j<span class="token operator">></span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//因为基准点取的是最左边的，所以要先从找后面中比基准点小的数，</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">>=</span>key<span class="token operator">&amp;&amp;</span>j<span class="token operator">></span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果比关键值大的，比较下一个，直到有比关键值小的</span>        j<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//再找前面中比基准点小的数</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>key<span class="token operator">&amp;&amp;</span>j<span class="token operator">></span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果比关键值小的，比较下一个，直到有比关键值大的</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//如果满足条件，则交换上面两个while找到的右边比关键值小的和左边比关键值大的两个数</span>        <span class="token keyword">int</span> temp<span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>key<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//此时low=high</span>    <span class="token function">QuickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>low<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递归调用左半数组</span>    <span class="token function">QuickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递归调用左半数组</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4）时间复杂度分析-1"><a href="#4）时间复杂度分析-1" class="headerlink" title="4）时间复杂度分析"></a>4）时间复杂度分析</h3><p>O（nlogn）</p><h3 id="5）优化"><a href="#5）优化" class="headerlink" title="5）优化"></a>5）优化</h3><p>可以优选基准值的位置，如果我们选取的基准点处于整个序列的中间位置，那么我们就可以将整个序列分成小数集合和大数集合。我们可以选取 三数取中，即取三个关键字先进行排序，将中间数作为基准点，一般是取左端、右端和中间三个数。</p><h2 id="6、归并排序"><a href="#6、归并排序" class="headerlink" title="6、归并排序"></a>6、归并排序</h2><h3 id="1）简介-5"><a href="#1）简介-5" class="headerlink" title="1）简介"></a>1）简介</h3><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer） 策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修 补”在一起，即分而治之)。</p><h3 id="2）图解-4"><a href="#2）图解-4" class="headerlink" title="2）图解"></a>2）图解</h3><p><img src="img%5C%E5%B9%B6%E5%BD%92%E6%8E%92%E5%BA%8F1.png" alt=""></p><p>在治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将 [4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤</p><p><img src="img%5C%E5%B9%B6%E5%BD%92%E6%8E%92%E5%BA%8F2.png" alt=""></p><h3 id="3）代码实现-4"><a href="#3）代码实现-4" class="headerlink" title="3）代码实现"></a>3）代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>jc<span class="token punctuation">.</span>demo1<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr3 <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//合并的方法</span>  <span class="token comment" spellcheck="true">/**   *   * @param arr 排序的原始数组   * @param left 左边有序序列的初始索引   * @param mid 中间索引   * @param right 右边索引   * @param temp 做中转的数组   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> mid<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化 i, 左边有序序列的初始索引</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//初始化 j, 右边有序序列的初始索引</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向 temp 数组的当前索引</span>    <span class="token comment" spellcheck="true">//(一)</span>    <span class="token comment" spellcheck="true">//先把左右两边(有序)的数据按照规则填充到 temp 数组</span>    <span class="token comment" spellcheck="true">//直到左右两边的有序序列，有一边处理完毕为止</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//继续</span>      <span class="token comment" spellcheck="true">//如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span>      <span class="token comment" spellcheck="true">// 即将左边的当前元素，填充到 temp 数组</span>      <span class="token comment" spellcheck="true">//然后 t++, i++</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        temp<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        t <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//反之,将右边有序序列的当前元素，填充到 temp 数组</span>        temp<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        t <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        j <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//以上if语句作用就是将arr[i]和arr[j]小的那个填充到temp数组，并右移被填充的那个序列索引</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//(二)</span>    <span class="token comment" spellcheck="true">//把有剩余数据的一边的数据依次全部填充到 temp</span>    <span class="token comment" spellcheck="true">//因为子序经过前面的分处理，已是有序，再经过以上一的处理，剩余的数据已经都大于temp[t]，所以全部移过来</span>    <span class="token keyword">while</span><span class="token punctuation">(</span> i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//左边的有序序列还有剩余的元素，就全部填充到temp，如图二中的第五步</span>      temp<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      t <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>      i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//右边的有序序列还有剩余的元素，就全部填充到temp</span>      temp<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>      t <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>      j <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//(三)</span>    <span class="token comment" spellcheck="true">//将 temp 数组的元素拷贝到arr</span>    <span class="token comment" spellcheck="true">//注意，并不是每次都拷贝所有（9个）</span>    t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tempLeft <span class="token operator">=</span> left<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//</span>    <span class="token comment" spellcheck="true">//第一次合并 tempLeft = 0 , right = 1 // tempLeft = 2 right = 3 // tL=0 ri=3</span>    <span class="token comment" spellcheck="true">// 最后一次 tempLeft = 0 right = 7</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tempLeft <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>      arr<span class="token punctuation">[</span>tempLeft<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>      t <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>      tempLeft <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//分+合方法</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//中间索引</span>    <span class="token comment" spellcheck="true">//向左递归进行分解</span>      <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//向右递归进行分解</span>      <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//全部分解后，合并</span>      <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4）时间复杂度分析-2"><a href="#4）时间复杂度分析-2" class="headerlink" title="4）时间复杂度分析"></a>4）时间复杂度分析</h3><p>时间复杂度：O(nlogn）空间复杂度：O(n+logn）</p><h2 id="7、基数排序"><a href="#7、基数排序" class="headerlink" title="7、基数排序"></a>7、基数排序</h2><h3 id="1）简介-6"><a href="#1）简介-6" class="headerlink" title="1）简介"></a>1）简介</h3><ul><li>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾<br>名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</li><li>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法</li><li>基数排序(Radix Sort)是桶排序的扩展</li><li>基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个<br>位数分别比较。</li></ul><p>它的基本思想是将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p><h3 id="2）图解-5"><a href="#2）图解-5" class="headerlink" title="2）图解"></a>2）图解</h3><p><img src="img%5Cimage-20200624142734617.png" alt="image-20200624142734617"></p><p><img src="img%5Cimage-20200624142808557.png" alt="image-20200624142808557"></p><p><img src="img%5Cimage-20200624142820399.png" alt="image-20200624142820399"></p><h3 id="3）代码实现-5"><a href="#3）代码实现-5" class="headerlink" title="3）代码实现"></a>3）代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>jc<span class="token punctuation">.</span>demo1<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RadixSort</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr3 <span class="token operator">=</span> <span class="token function">radixSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1. 得到数组中最大的数的位数</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//假设第一数就是最大数 for(int i = 1; i &lt; arr.length; i++) {</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>        max <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//得到最大数是几位数</span>    <span class="token keyword">int</span> maxLength <span class="token operator">=</span> <span class="token punctuation">(</span>max <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义一个二维数组，表示 10 个桶, 每个桶就是一个一维数组</span>    <span class="token comment" spellcheck="true">//说明</span>    <span class="token comment" spellcheck="true">//1. 二维数组包含 10 个一维数组</span>    <span class="token comment" spellcheck="true">//2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为 arr.length</span>    <span class="token comment" spellcheck="true">//3. 很明确，基数排序是使用空间换时间的经典算法</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span>    <span class="token comment" spellcheck="true">//比如：bucketElementCounts[0] , 记录的就是 bucket[0] 桶的放入数据个数</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucketElementCounts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//循环取出各个位数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> n <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//取出每个元素的对应位的值</span>        <span class="token keyword">int</span> digitOfElement <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">/</span> n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//放入到对应的桶中</span>        bucket<span class="token punctuation">[</span>digitOfElement<span class="token punctuation">]</span><span class="token punctuation">[</span>bucketElementCounts<span class="token punctuation">[</span>digitOfElement<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        bucketElementCounts<span class="token punctuation">[</span>digitOfElement<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span>      <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//遍历每一桶，并将桶中是数据，放入到原数组</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> bucketElementCounts<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果桶中，有数据，我们才放入到原数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bucketElementCounts<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//循环该桶即第k 个桶(即第 k 个一维数组), 放入</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> bucketElementCounts<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//取出元素放入到 arr</span>            arr<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//第 i+1 轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span>        bucketElementCounts<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//System.out.println("第"+(i+1)+"轮，对个位的排序处理 arr =" + Arrays.toString(arr));</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4-说明"><a href="#4-说明" class="headerlink" title="4)说明"></a>4)说明</h3><p>1) 基数排序是对传统桶排序的扩展，速度很快.<br>2) 基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。 3) 基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些<br>记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且 r[i]在 r[j]之前，而在排序后的序列中，r[i]仍在 r[j]之前， 则称这种排序算法是稳定的；否则称为不稳定的]<br>4) 有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: <a href="https://code.i-harness.com/zh-CN/q/e98fa9" target="_blank" rel="noopener">https://code.i-harness.com/zh-CN/q/e98fa9</a></p><h2 id="8、堆排序"><a href="#8、堆排序" class="headerlink" title="8、堆排序"></a>8、堆排序</h2><h3 id="1）简介-7"><a href="#1）简介-7" class="headerlink" title="1）简介"></a>1）简介</h3><p>1) 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复 杂度均为 O(nlogn)，它也是不稳定排序。<br>2) 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有<br>要求结点的左孩子的值和右孩子的值的大小关系。<br>3) 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆<br>4) 大顶堆举例说明</p><p><img src="img%5C%E5%A0%86%E6%8E%92%E5%BA%8F1.png" alt=""></p><p>5）小顶堆举例说明</p><p><img src="img%5C%E5%A0%86%E6%8E%92%E5%BA%8F2.png" alt=""></p><p>6) 一般升序采用大顶堆，降序采用小顶堆</p><h3 id="2）基本思想"><a href="#2）基本思想" class="headerlink" title="2）基本思想"></a>2）基本思想</h3><p>堆排序的基本思想是：</p><p>1) 将待排序序列构造成一个大顶堆<br>2) 此时，整个序列的最大值就是堆顶的根节点。<br>3) 将其与末尾元素进行交换，此时末尾就为最大值。<br>4) 然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序<br>序列了。</p><p>可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了. </p><h3 id="3）图解"><a href="#3）图解" class="headerlink" title="3）图解"></a>3）图解</h3><p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p><p>1) .假设给定无序序列结构如下</p><p><img src="img%5C%E5%A0%86%E6%8E%92%E5%BA%8F3.png" alt=""></p><p>2) .此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。</p><p><img src="img%5C%E5%A0%86%E6%8E%92%E5%BA%8F4.png" alt=""></p><p>3) .找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换。且这是8比9小。没有破坏结构，否则需要交换。</p><p><img src="img%5C%E5%A0%86%E6%8E%92%E5%BA%8F5.png" alt=""></p><p>4) 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6。</p><p><img src="img%5C%E5%A0%86%E6%8E%92%E5%BA%8F6.png" alt=""></p><p>此时，我们就将一个无序序列构造成了一个大顶堆。</p><p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p><p>1) .将堆顶元素 9 和末尾元素 4 进行交换</p><p><img src="img%5C%E5%A0%86%E6%8E%92%E5%BA%8F7.png" alt=""></p><p>2) .重新调整结构，使其继续满足堆定义</p><p><img src="img%5C%E5%A0%86%E6%8E%92%E5%BA%8F8.png" alt=""></p><p>3) .再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8.</p><p><img src="img%5C%E5%A0%86%E6%8E%92%E5%BA%8F9.png" alt=""></p><p>4) 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p><p><img src="img%5C%E5%A0%86%E6%8E%92%E5%BA%8F10.png" alt=""></p><p>再简单总结下堆排序的基本思路：<br>1).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</p><p>2).将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</p><p>3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤， 直到整个序列有序。</p><h3 id="4）代码实现"><a href="#4）代码实现" class="headerlink" title="4）代码实现"></a>4）代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>tree<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>text<span class="token punctuation">.</span>SimpleDateFormat<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//要求将数组进行升序排序</span>        <span class="token comment" spellcheck="true">//int arr[] = {4, 6, 8, 5, 9};</span>        <span class="token comment" spellcheck="true">// 创建要给80000个的随机的数组</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">8000000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">8000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 生成一个[0, 8000000) 数</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Date data1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SimpleDateFormat simpleDateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String date1Str <span class="token operator">=</span> simpleDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>data1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序前的时间是="</span> <span class="token operator">+</span> date1Str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">heapSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        Date data2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String date2Str <span class="token operator">=</span> simpleDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>data2<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序前的时间是="</span> <span class="token operator">+</span> date2Str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//System.out.println("排序后=" + Arrays.toString(arr));</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//编写一个堆排序的方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"堆排序!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        //分步完成</span><span class="token comment" spellcheck="true">//        adjustHeap(arr, 1, arr.length);</span><span class="token comment" spellcheck="true">//        System.out.println("第一次" + Arrays.toString(arr)); // 4, 9, 8, 5, 6</span><span class="token comment" spellcheck="true">//        </span><span class="token comment" spellcheck="true">//        adjustHeap(arr, 0, arr.length);</span><span class="token comment" spellcheck="true">//        System.out.println("第2次" + Arrays.toString(arr)); // 9,6,8,5,4</span>        <span class="token comment" spellcheck="true">//完成我们最终代码</span>        <span class="token comment" spellcheck="true">//将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*         * 2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;　　            3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。         */</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//交换</span>            temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//System.out.println("数组=" + Arrays.toString(arr)); </span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//将一个数组(二叉树), 调整成一个大顶堆</span>    <span class="token comment" spellcheck="true">/**     * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆     * 举例  int arr[] = {4, 6, 8, 5, 9}; => i = 1 => adjustHeap => 得到 {4, 9, 8, 5, 6}     * 如果我们再次调用  adjustHeap 传入的是 i = 0 => 得到 {4, 9, 8, 5, 6} => {9,6,8,5, 4}     * @param arr 待调整的数组     * @param i 表示非叶子结点在数组中索引     * @param lenght 表示对多少个元素继续调整， length 是在逐渐的减少     */</span>    <span class="token keyword">public</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">adjustHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> lenght<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先取出当前元素的值，保存在临时变量</span>        <span class="token comment" spellcheck="true">//开始调整</span>        <span class="token comment" spellcheck="true">//说明</span>        <span class="token comment" spellcheck="true">//1. k = i * 2 + 1 k 是 i结点的左子结点</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> lenght<span class="token punctuation">;</span> k <span class="token operator">=</span> k <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> lenght <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//说明左子结点的值小于右子结点的值</span>                k<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// k 指向右子结点</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果子结点大于父结点</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把较大的值赋给当前结点</span>                i <span class="token operator">=</span> k<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//!!! i 指向 k,继续循环比较</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//!</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部)</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将temp值放到调整后的位置</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="四、各排序算法比较"><a href="#四、各排序算法比较" class="headerlink" title="四、各排序算法比较"></a>四、各排序算法比较</h1><p><img src="img%5Cimage-20200624145848028.png" alt="image-20200624145848028"></p><p>1) 稳定：如果 a 原本在 b 前面，而 a=b，排序之后a 仍然在 b 的前面；<br>2) 不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后a 可能会出现在 b 的后面；<br>3) 内排序：所有排序操作都在内存中完成；<br>4) 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p><p>5) 时间复杂度： 一个算法执行所耗费的时间。<br>6) 空间复杂度：运行完一个程序所需内存的大小。 7) n: 数据规模<br>8) k: “桶”的个数<br>9) In-place: 不占用额外内存<br>10) Out-place: 占用额外内存</p><h1 id="五、排序算法的选择"><a href="#五、排序算法的选择" class="headerlink" title="五、排序算法的选择"></a>五、排序算法的选择</h1><p>没有一种算法显然是“最佳”算法。这取决于一系列因素。</p><p>首先，能将数据放入主内存吗？如果你能，那么需要依赖外部排序算法。这些算法通常基于快速排序（quicksort）和归并排序（mergesort），【译注：如果不能，根据使用的数据集的大小和类型，使用专用数据库加载数据或利用Google的BigQuery等基于云的服务】。</p><p>其次，输入数据的分布是什么样的？如果它大多数都是有序的，那么像Timsort这样的东西可能是一个很好的选择，因为它的设计可以很好地处理排序数据。如果它几乎是随机的，那么Timsort可能不是一个好选择。</p><p>第三，排序什么类型的的元素？如果要对一般对象进行排序，那么几乎可以锁定比较排序。如果没有，也许可以使用非比较排序，如计算排序（counting sort）或基数排序（radix sort）。</p><p>第四，数据有多少模块？一些排序算法（quicksort，mergesort，MSD基数排序）非常好并行化，而其他排序算法（如heapsort）则不是好的选择。</p><p>第五，数据如何表示？如果它们存储在数组中，则快速排序或快速排序变体可能会因为引用的位置而表现良好，而mergesort可能由于需要额外的内存而变慢。但是，如果它们在链表中，则来自quicksort的引用位置消失，mergesort再次突然变得具有竞争力。</p><p>最好的选择可能是考虑很多不同的因素，然后从那里做出决定。设计和研究算法如此有趣的原因之一是，很少有一个单一的最佳选择;通常，最好的选择取决于具体情况和根据所看到的情况而变化。</p><p>（虽然quicksort有一个退化的O（n2）最坏的情况，但是有很多方法可以避免这种情况。如果看起来快速排序会退化，则内省排序（introsort）算法会跟踪递归深度并将算法切换到堆栈。这可以保证O（n log n）最坏情况下的内存开销，并最大限度地提高从quicksort获得的好处随机快速排序虽然仍然具有O（n2）最坏情况，但实际上击中最坏情况的概率极小。</p><p>Heapsort在实践中是一种很好的算法，但在某些情况下并不像其他算法那么快，因为它没有良好的参考局部性。也就是说，它永远不会退化并只需要O（1）辅助空间这一事实是一个巨大的卖点。</p><p>Mergesort确实需要大量的辅助内存，这就是为什么在有大量数据需要排序时可能不想使用它的原因之一。但值得了解的是，因为它的变体被广泛使用。）</p><p>本节参考自<a href="https://blog.csdn.net/iMatt/article/details/83781169" target="_blank" rel="noopener">https://blog.csdn.net/iMatt/article/details/83781169</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用算法</title>
      <link href="/2019/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/Java%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
      <url>/2019/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/Java%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、二分查找算法（非递归）"><a href="#一、二分查找算法（非递归）" class="headerlink" title="一、二分查找算法（非递归）"></a>一、二分查找算法（非递归）</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>​        二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找。<br>​        二分查找法的运行时间为对数时间O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n 步，假设从[0,99]的<br>队列(100 个数，即 n=100)中寻到目标数 30，则需要查找步数为㏒₂100 , 即最多需要查找 7 次( 2^6 &lt; 100 &lt; 2^7) </p><p>步骤：</p><ul><li>首先确定整个查找区间的中间位置 mid = （ left + right ）/ 2</li><li>用待查关键字值与中间位置的关键字值进行比较；<br>若相等，则查找成功<br>若大于，则在后（右）半个区域继续进行折半查找<br>若小于，则在前（左）半个区域继续进行折半查找</li><li>对确定的缩小区域再按折半公式，重复上述步骤。<br>最后，得到结果：要么查找成功， 要么查找失败。折半查找的存储结构采用一维数组存放</li></ul><p>优点：ASL≤log2n，即每经过一次比较,查找范围就缩小一半。经log2n 次计较就可以完成查找过程。</p><p>缺点：因要求有序，所以要求查找数列必须有序，而对所有数据元素按大小排序是非常费时的操作。另外，顺序存储结构的插入、删除操作不便利。</p><h2 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>jc<span class="token punctuation">.</span>demo1<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinarySearchNoRecur</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">54</span><span class="token punctuation">,</span><span class="token number">67</span><span class="token punctuation">,</span><span class="token number">81</span><span class="token punctuation">,</span><span class="token number">96</span><span class="token punctuation">,</span><span class="token number">234</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">81</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"该数不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"该数的下标为："</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> mid<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>        left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>        right<span class="token operator">=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="二、分治算法"><a href="#二、分治算法" class="headerlink" title="二、分治算法"></a>二、分治算法</h1><h2 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>1) 分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或<br>相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题 的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变 换)……<br>2) 分治算法可以求解的一些经典问题</p><ul><li>二分搜索</li><li>大整数乘法</li><li>棋盘覆盖</li><li>合并排序</li><li>快速排序</li><li>线性时间选择</li><li>最接近点对问题 </li><li>循环赛日程表</li><li>汉诺塔</li></ul><p>分治法在每一层递归上都有三个步骤：</p><p>1) 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题</p><p>2) 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p><p>3) 合并：将各个子问题的解合并为原问题的解。</p><p>分治(Divide-and-Conquer(P))算法设计模式如下：</p><p><img src="img%5C%E5%88%86%E5%80%BC%E7%AE%97%E6%B3%95.png" alt=""></p><h2 id="2、举例、代码实现"><a href="#2、举例、代码实现" class="headerlink" title="2、举例、代码实现"></a>2、举例、代码实现</h2><p>我们用经典的汉诺塔来举例：</p><p>​        有三根木桩，第一根上有n个盘子，最底层的盘子最大，最上层的盘子最小。汉诺塔问题就是将所有的盘子从第一根木桩开始，以第二根木桩为桥梁，全部搬到第三根木桩。</p><p>不过在搬动时，尚须遵守以下游戏规则：</p><p>1、每次只能从最上面移动一个盘子（乍一看，尼玛还真是栈）<br>2、任何盘子可以从任何木桩搬到其他木桩。<br>3、直径较小的盘子永远必须放在直径较大的盘子之上。</p><p>以下分析来自于：<a href="https://blog.csdn.net/da_jie/article/details/50866741" target="_blank" rel="noopener">https://blog.csdn.net/da_jie/article/details/50866741</a></p><p>解决思路：</p><ul><li><p>如果n=1，则将圆盘从A直接移动到C。</p></li><li><p>如果n=2，则：<br>1.将A上的n-1(等于1)个圆盘移到B上；<br>2.再将A上的一个圆盘移到C上；<br>3.最后将B上的n-1(等于1)个圆盘移到C上。</p></li><li><p>如果n=3，则：<br>A. 将A上的n-1(等于2，令其为n)个圆盘移到B(借助于C)，步骤如下：|<br>(1)将A上的n-1(等于1)个圆盘移到C上。<br>(2)将A上的一个圆盘移到B。<br>(3)将C上的n-1(等于1)个圆盘移到B。<br>B. 将A上的一个圆盘移到C。<br>C. 将B上的n-1(等于2，令其为n)个圆盘移到C(借助A)，步骤如下：<br>(1)将B上的n-1(等于1)个圆盘移到A。<br>(2)将B上的一个盘子移到C。<br>(3)将A上的n-1(等于1)个圆盘移到C。</p><p>到此，完成了三个圆盘的移动过程。</p></li></ul><p>从上面分析可以看出，当n大于等于2时，移动的过程可分解为三个步骤：</p><ul><li>第一步 把A上的n-1个圆盘移到B上；</li><li>第二步 把A上的一个圆盘移到C上；</li><li>第三步 把B上的n-1个圆盘移到C上；其中第一步和第三步是类同的。</li></ul><p>其实看到这里基本可以看出规律，就是用递归。</p><p>设盘数为n，</p><p>当n=1时，直接将盘从一号木桩转移到3号木桩</p><p>当n=2时，转移顺序：1号-&gt;2号，2号-&gt;3号，2号-&gt;3号</p><p>重点就是当n&gt;=3时，将第n个盘和上面的n-1个盘分离，整体看起来就剩下2个部分：n，(1<del>n-1)；后面递归就是将(1</del>n-1)分离成(1~n-2)和(n-1)…以此递归。</p><p>递归方法体面放四个参数，n(层数)，p1(一号桩)，p2(二号桩)，p3(三号桩)。每次递归(一号桩)是初始位置，(二号桩)为过渡位置，(三号桩)为目标位置</p><p>那么n&gt;=3时递归顺序便是：</p><p>先创建方法：public static void hanoiTower(int n, char a, char b, char c){….}</p><p>(1)将(1<del>n-1)分离放到(二号桩)，这里就是(1</del>n-1)在一号桩(初始位置)，二号桩就是目标位置</p><p>第一次递归代码:hanoiTower(n-1,a,c,b)，说到底，真正有用的参数只有3个，第1个、第2个、第4个；第三个参数就是打酱油的，你也可以认为是借助工具。</p><p>(2)将n转移到(三号桩)，按规矩，应该是hanoiTower(n-1,a,b,c)；但是这里写了第一是个死循环，第二，n转移没有借助b，所以默认他很自觉，自己到三号桩，直接</p><p>System.out.println(“从”+p1+”移动到”+p3);</p><p>(3)将(1~n-1)从(二号桩)转移到(三号桩),方法看懂(1)的这里自然懂</p><p>hanoiTower(n-1,b,a,c);</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>jc<span class="token punctuation">.</span>demo1<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hanoitower</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">hanoiTower</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//汉诺塔的移动的方法</span>  <span class="token comment" spellcheck="true">//使用分治算法</span>  <span class="token comment" spellcheck="true">//第一个参数为多少个盘，第二个参数为初始桩，第三个参数为过渡桩，第四个参数为目标桩</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hanoiTower</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> a<span class="token punctuation">,</span> <span class="token keyword">char</span> b<span class="token punctuation">,</span> <span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果只有一个盘</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第1个盘从 "</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token string">"->"</span> <span class="token operator">+</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//如果我们有 n >= 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘（即第n个盘） 2. 上面的其余所有盘（n-1个）</span>      <span class="token comment" spellcheck="true">//1. 先把最上面的n-1个盘 A->B， 移动过程会使用到 c</span>      <span class="token function">hanoiTower</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> c<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//2. 把最下边的盘n A->C</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span> <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token string">"个盘从 "</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token string">"->"</span> <span class="token operator">+</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//3. 把B塔的n-1 从 B->C , 移动过程使用到A</span>      <span class="token function">hanoiTower</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> a<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><pre><code>第1个盘从 A-&gt;C第2个盘从 A-&gt;B第1个盘从 C-&gt;B第3个盘从 A-&gt;C第1个盘从 B-&gt;A第2个盘从 B-&gt;C第1个盘从 A-&gt;C第4个盘从 A-&gt;B第1个盘从 C-&gt;B第2个盘从 C-&gt;A第1个盘从 B-&gt;A第3个盘从 C-&gt;B第1个盘从 A-&gt;C第2个盘从 A-&gt;B第1个盘从 C-&gt;B第5个盘从 A-&gt;C第1个盘从 B-&gt;A第2个盘从 B-&gt;C第1个盘从 A-&gt;C第3个盘从 B-&gt;A第1个盘从 C-&gt;B第2个盘从 C-&gt;A第1个盘从 B-&gt;A第4个盘从 B-&gt;C第1个盘从 A-&gt;C第2个盘从 A-&gt;B第1个盘从 C-&gt;B第3个盘从 A-&gt;C第1个盘从 B-&gt;A第2个盘从 B-&gt;C第1个盘从 A-&gt;C</code></pre><h1 id="三、动态规划"><a href="#三、动态规划" class="headerlink" title="三、动态规划"></a>三、动态规划</h1><h2 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>1) 动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解<br>的处理算法<br>2) 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这<br>些子问题的解得到原问题的解。<br>3) 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子<br>阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )<br>4) 动态规划可以通过填表的方式来逐步推进，得到最优解.</p><h2 id="2、适用情况"><a href="#2、适用情况" class="headerlink" title="2、适用情况"></a>2、适用情况</h2><p>能采用动态规划求解的问题的一般要具有3个性质：</p><p>（1）最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p><p>（2） 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p><p>（3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p><h2 id="3、基本步骤"><a href="#3、基本步骤" class="headerlink" title="3、基本步骤"></a>3、基本步骤</h2><p>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p><p>  初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</p><p>​            图1 动态规划决策过程示意图</p><p>  (1)<strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p><p>  (2)<strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p><p>  (3)<strong>确定决策并写出状态转移方程</strong>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p><p>  (4)<strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p><p>   一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p><p>实际应用中可以按以下几个简化的步骤进行设计：</p><p>   （1）分析最优解的性质，并刻画其结构特征。</p><p>   （2）递归的定义最优解。</p><p>   （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</p><p>   （4）根据计算最优值时得到的信息，构造问题的最优解</p><h2 id="4、举例、代码实现"><a href="#4、举例、代码实现" class="headerlink" title="4、举例、代码实现"></a>4、举例、代码实现</h2><p>背包问题：有一个背包，容量为 4 磅 ， 现有如下物品</p><p><img src="img%5C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png" alt=""></p><p>1) 要求达到的目标为装入的背包的总价值最大，并且重量不超出 </p><p>2) 要求装入的物品不能重复</p><p>思路分析和图解<br>3) 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价<br>值最大。其中又分 01 背包和完全背包(完全背包指的是：每种物品都有无限件可用) </p><p>4) 这里的问题属于 01 背包，即每个物品最多放一个。而无限背包可以转化为01 背包。</p><p>5) 算法的主要思想，利用动态规划来解决。每次遍历到的第 i 个物品，根据 w[i]和 v[i]来确定是否需要将该物品 放入背包中。即对于给定的 n 个物品，设 v[i]、w[i]分别为第 i 个物品的价值和重量，C 为背包的容量。再令 v[i][j] 表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值。则我们有下面的结果：<br><img src="img%5C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922.PNG" alt=""></p><p><img src="img%5C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%923.png" alt=""></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>dynamic<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KnapsackProblem</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> w <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//物品的重量</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> val <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1500</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//物品的价值 这里val[i] 就是前面讲的v[i]</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//背包的容量</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> val<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//物品的个数</span>        <span class="token comment" spellcheck="true">//创建二维数组，</span>        <span class="token comment" spellcheck="true">//v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//为了记录放入商品的情况，我们定一个二维数组</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将第一列设置为0</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将第一行设置0</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//根据前面得到公式来动态规划处理</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//不处理第一行 i是从1开始的</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//不处理第一列, j是从1开始的</span>                <span class="token comment" spellcheck="true">//公式</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>w<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 因为我们程序i 是从1开始的，因此原来公式中的 w[i] 修改成 w[i-1]</span>                    v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//说明:</span>                    <span class="token comment" spellcheck="true">//因为我们的i 从1开始的， 因此公式需要调整成</span>                    <span class="token comment" spellcheck="true">//v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);</span>                    <span class="token comment" spellcheck="true">//v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);</span>                    <span class="token comment" spellcheck="true">//为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else来体现公式</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> val<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> w<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> w<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//把当前的情况记录到path</span>                        path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//输出一下v 看看目前的情况</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"============================"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出最后我们是放入的哪些商品</span>        <span class="token comment" spellcheck="true">//遍历path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入</span><span class="token comment" spellcheck="true">//        for(int i = 0; i &lt; path.length; i++) {</span><span class="token comment" spellcheck="true">//            for(int j=0; j &lt; path[i].length; j++) {</span><span class="token comment" spellcheck="true">//                if(path[i][j] == 1) {</span><span class="token comment" spellcheck="true">//                    System.out.printf("第%d个商品放入到背包\n", i);</span><span class="token comment" spellcheck="true">//                }</span><span class="token comment" spellcheck="true">//            }</span><span class="token comment" spellcheck="true">//        }</span>        <span class="token comment" spellcheck="true">//动脑筋</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> path<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//行的最大下标</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//列的最大下标</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//从path的最后开始找</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"第%d个商品放入到背包\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                 j <span class="token operator">-=</span> w<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//w[i-1]</span>            <span class="token punctuation">}</span>            i<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出</p><pre><code>0 0 0 0 0 0 1500 1500 1500 1500 0 1500 1500 1500 3000 0 1500 1500 2000 3500 ============================第3个商品放入到背包第1个商品放入到背包</code></pre><h1 id="四、KMP算法"><a href="#四、KMP算法" class="headerlink" title="四、KMP算法"></a>四、KMP算法</h1><h2 id="1、介绍-3"><a href="#1、介绍-3" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>1) KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法<br>2) Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置.<br>3) KMP 方法算法就利用之前判断过信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间<br>4) 参考资料：<a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html" target="_blank" rel="noopener">https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</a></p><h2 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h2><p>字符串匹配问题：：</p><p>1) 有一个字符串 str1= “BBC ABCDAB ABCDABCDABDE”，和一个子串 str2=”ABCDABD”<br>2) 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</p><h2 id="3、暴力匹配"><a href="#3、暴力匹配" class="headerlink" title="3、暴力匹配"></a>3、暴力匹配</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>kmp<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ViolenceMatch</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//测试暴力匹配算法</span>        String str1 <span class="token operator">=</span> <span class="token string">"BBC ABCDAB ABCDABCDABDE"</span><span class="token punctuation">;</span>        String str2 <span class="token operator">=</span> <span class="token string">"ABCDABD"</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">violenceMatch</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"index="</span> <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 暴力匹配算法实现</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">violenceMatch</span><span class="token punctuation">(</span>String str1<span class="token punctuation">,</span> String str2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s1 <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s2 <span class="token operator">=</span> str2<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> s1Len <span class="token operator">=</span> s1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> s2Len <span class="token operator">=</span> s2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// i索引指向s1</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// j索引指向s2</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> s1Len <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> s2Len<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 保证匹配时，不越界</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//匹配ok</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//没有匹配成功</span>                <span class="token comment" spellcheck="true">//如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。</span>                i <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//i要跳过j-1，从i-（j-1）开始</span>                j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//j要恢复</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//判断是否匹配成功</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> s2Len<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="4、KMP图解"><a href="#4、KMP图解" class="headerlink" title="4、KMP图解"></a>4、KMP图解</h2><p>1.首先，用 Str1 的第一个字符和 Str2 的第一个字符去比较，不符合，关键词向后移动一位</p><p><img src="img%5CKMP1.png" alt=""></p><p>2、重复第一步，还是不符合，再后移</p><p><img src="img%5CKMP2.png" alt=""></p><p>3、一直重复，直到 Str1 有一个字符与 Str2 的第一个字符符合为止</p><p><img src="img%5CKMP3.png" alt=""></p><p>4、接着比较字符串和搜索词的下一个字符，还是符合。</p><p><img src="img%5CKMP4.png" alt=""></p><p>5.遇到 Str1 有一个字符与 Str2 对应的字符不符合。</p><p><img src="img%5CKMP5.png" alt=""></p><p>6.这时候，想到的是继续遍历 Str1 的下一个字符，重复第 1 步。(其实是很不明智的，因为此时BCD 已经比较过了， 没有必要再做重复的工作，一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是”ABCDAB”。 KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这 样就提高了效率。)</p><p><img src="img%5CKMP6.png" alt=""></p><p>7.怎么做到把刚刚重复的步骤省略掉？可以对 Str2 计算出一张《部分匹配表》，这张表的产生在后面介绍</p><p><img src="img%5CKMP7.png" alt=""></p><p>8.已知空格与 D 不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符 B 对应的”部分 匹配值”为 2，因此按照下面的公式算出向后移动的位数：<br>移动位数 = 已匹配的字符数 - 对应的部分匹配值<br>因为 6 - 2 等于 4，所以将搜索词向后移动 4 位。</p><p>9.因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值” 为 0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移 2 位。</p><p><img src="img%5CKMP8.png" alt=""></p><p>10.因为空格与 A 不匹配，继续后移一位。</p><p><img src="img%5CKMP9.png" alt=""></p><p>11.逐位比较，直到发现 C 与 D 不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动 4 位。</p><p><img src="img%5CKMP10.png" alt=""></p><p>12.逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配）， 移动位数 = 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了。</p><p><img src="img%5CKMP11.png" alt=""></p><p>13.介绍《部分匹配表》怎么产生的 先介绍前缀，后缀是什么</p><p><img src="img%5CKMP123.png" alt=""></p><p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，<br>－”A”的前缀和后缀都为空集，共有元素的长度为 0；<br>－”AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；<br>－”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；<br>－”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；<br>－”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1； －”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”， 长度为 2；<br>－”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为 0。</p><p>14.”部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么 它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动 4 位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p><p><img src="img%5CKMP13.png" alt=""></p><h2 id="5、KMP代码实现"><a href="#5、KMP代码实现" class="headerlink" title="5、KMP代码实现"></a>5、KMP代码实现</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>kmp<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KMPAlgorithm</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String str1 <span class="token operator">=</span> <span class="token string">"BBC ABCDAB ABCDABCDABDE"</span><span class="token punctuation">;</span>        String str2 <span class="token operator">=</span> <span class="token string">"ABCDABD"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//String str2 = "BBC";</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> next <span class="token operator">=</span> <span class="token function">kmpNext</span><span class="token punctuation">(</span><span class="token string">"ABCDABD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[0, 1, 2, 0]</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"next="</span> <span class="token operator">+</span> Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">kmpSearch</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"index="</span> <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 15了</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//写出我们的kmp搜索算法</span>    <span class="token comment" spellcheck="true">/**     *      * @param str1 源字符串     * @param str2 子串     * @param next 部分匹配表, 是子串对应的部分匹配表     * @return 如果是-1就是没有匹配到，否则返回第一个匹配的位置     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">kmpSearch</span><span class="token punctuation">(</span>String str1<span class="token punctuation">,</span> String str2<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//遍历 </span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//需要处理 str1.charAt(i) ！= str2.charAt(j), 去调整j的大小</span>            <span class="token comment" spellcheck="true">//KMP算法核心点, 可以验证...</span>            <span class="token keyword">while</span><span class="token punctuation">(</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> str1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> str2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//因为相等的时候j都在++，当不相等了需要调整j的大小</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> str2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> str2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//j遍历完了就找到了</span>                <span class="token keyword">return</span> i <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span>  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果没有就返回-1</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//获取到一个字符串(子串) 的部分匹配值表</span>    <span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">kmpNext</span><span class="token punctuation">(</span>String dest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建一个next 数组保存部分匹配值</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>dest<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果字符串是长度为1 部分匹配值就是0</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dest<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//当dest.charAt(i) != dest.charAt(j) ，我们需要从next[j-1]获取新的j</span>            <span class="token comment" spellcheck="true">//直到我们发现 有  dest.charAt(i) == dest.charAt(j)成立才退出</span>            <span class="token comment" spellcheck="true">//这时kmp算法的核心点 他总是成立</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dest<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> dest<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//当dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就是+1</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dest<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> dest<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><pre><code>next=[0, 0, 0, 0, 1, 2, 0]index=15</code></pre><h1 id="五、贪心算法"><a href="#五、贪心算法" class="headerlink" title="五、贪心算法"></a>五、贪心算法</h1><h2 id="1、介绍-4"><a href="#1、介绍-4" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>1) 贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而<br>希望能够导致结果是最好或者最优的算法</p><p>2) 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</p><h2 id="2、案例-1"><a href="#2、案例-1" class="headerlink" title="2、案例"></a>2、案例</h2><p>1) 假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有<br>的地区都可以接收到信号</p><p><img src="img%5C%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%951.png" alt=""></p><p>2) 思路分析:<br>如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假<br>设总的有 n 个广播台，则广播台的组合总共有<br>2ⁿ -1 个,假设每秒可以计算 10 个子集， 如图:</p><p><img src="img%5C%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%952.png" alt=""></p><p>使用贪婪算法，效率高:</p><p>1) 目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择<br>策略上，因为需要覆盖全部地区的最小集合:<br>2) 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关<br>系）<br>3) 将这个电台加入到一个集合中(比如 ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。<br>4) 重复第 1 步直到覆盖了全部的地区<br>分析的图解:</p><p><img src="img%5C%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%953.png" alt=""></p><p>比如，在第一轮时，遍历所有的电台，求出每个广播台能够覆盖的地区（之前尚未被覆盖的地区）的个数，第一轮的时候分别是3,3,3,2,2。因为k2没有超过k1，所以选择k1，这时我们需要将待覆盖地区集合allAreas集合中k1已经覆盖到的地区去掉，即allAreas变成了{广州，深圳，成都，杭州，大连}，第二轮遍历开始，这时对比allAreas集合，每个广播台能够覆盖的地区（尚未被覆盖的地区）的个数分别为0,2,2,1,2,选择k2，再在allAreas集合中去掉k2新覆盖的两个地区，一直循环，直至allAreas为null</p><h2 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>greedy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashSet<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GreedyAlgorithm</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建广播电台,放入到Map</span>        HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>HashSet<span class="token operator">&lt;</span>String<span class="token operator">>></span> broadcasts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> HashSet<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将各个电台放入到broadcasts</span>        HashSet<span class="token operator">&lt;</span>String<span class="token operator">></span> hashSet1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hashSet1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"北京"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hashSet1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"上海"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hashSet1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"天津"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HashSet<span class="token operator">&lt;</span>String<span class="token operator">></span> hashSet2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hashSet2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"广州"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hashSet2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"北京"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hashSet2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"深圳"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HashSet<span class="token operator">&lt;</span>String<span class="token operator">></span> hashSet3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hashSet3<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"成都"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hashSet3<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"上海"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hashSet3<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"杭州"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HashSet<span class="token operator">&lt;</span>String<span class="token operator">></span> hashSet4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hashSet4<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"上海"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hashSet4<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"天津"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HashSet<span class="token operator">&lt;</span>String<span class="token operator">></span> hashSet5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hashSet5<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"杭州"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hashSet5<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"大连"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//加入到map</span>        broadcasts<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"K1"</span><span class="token punctuation">,</span> hashSet1<span class="token punctuation">)</span><span class="token punctuation">;</span>        broadcasts<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"K2"</span><span class="token punctuation">,</span> hashSet2<span class="token punctuation">)</span><span class="token punctuation">;</span>        broadcasts<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"K3"</span><span class="token punctuation">,</span> hashSet3<span class="token punctuation">)</span><span class="token punctuation">;</span>        broadcasts<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"K4"</span><span class="token punctuation">,</span> hashSet4<span class="token punctuation">)</span><span class="token punctuation">;</span>        broadcasts<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"K5"</span><span class="token punctuation">,</span> hashSet5<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//allAreas 存放所有的地区</span>        HashSet<span class="token operator">&lt;</span>String<span class="token operator">></span> allAreas <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        allAreas<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"北京"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        allAreas<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"上海"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        allAreas<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"天津"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        allAreas<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"广州"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        allAreas<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"深圳"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        allAreas<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"成都"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        allAreas<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"杭州"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        allAreas<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"大连"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建ArrayList, 存放选择的电台集合</span>        ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> selects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集</span>        <span class="token comment" spellcheck="true">//还没覆盖的地区即图解中的allAreas，最初是全部，即均需要被覆盖，随着有地区被覆盖，allAreas逐渐变小</span>        HashSet<span class="token operator">&lt;</span>String<span class="token operator">></span> tempSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//定义给maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key</span>        <span class="token comment" spellcheck="true">//如果maxKey 不为null , 则会加入到 selects</span>        String maxKey <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>allAreas<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果allAreas 不为0, 则表示还没有覆盖到所有的地区</span>            <span class="token comment" spellcheck="true">//每进行一次while,需要</span>            maxKey <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//遍历 broadcasts, 取出对应key</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>String key <span class="token operator">:</span> broadcasts<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//每进行一次for</span>                tempSet<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//当前这个key能够覆盖的地区</span>                HashSet<span class="token operator">&lt;</span>String<span class="token operator">></span> areas <span class="token operator">=</span> broadcasts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                tempSet<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>areas<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//求出tempSet和allAreas 集合的交集, 交集会赋给 tempSet</span>                tempSet<span class="token punctuation">.</span><span class="token function">retainAll</span><span class="token punctuation">(</span>allAreas<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多</span>                <span class="token comment" spellcheck="true">//就需要重置maxKey</span>                <span class="token comment" spellcheck="true">// tempSet.size() >broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>tempSet<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                         <span class="token punctuation">(</span>maxKey <span class="token operator">==</span> null <span class="token operator">||</span> tempSet<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span>broadcasts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>maxKey<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    maxKey <span class="token operator">=</span> key<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//maxKey != null, 就应该将maxKey 加入selects</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>maxKey <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                selects<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>maxKey<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//将maxKey指向的广播电台覆盖的地区，从 allAreas 去掉</span>                allAreas<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>broadcasts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>maxKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"得到的选择结果是"</span> <span class="token operator">+</span> selects<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//[K1,K2,K3,K5]        </span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><pre><code>得到的选择结果是[K1, K2, K3, K5]</code></pre><h1 id="六、普利姆算法"><a href="#六、普利姆算法" class="headerlink" title="六、普利姆算法"></a>六、普利姆算法</h1><h2 id="1、介绍-5"><a href="#1、介绍-5" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>普利姆(Prim)算法求最小生成树，也就是在包含 n 个顶点的连通图中，找出只有(n-1)条边包含所有 n 个顶点的<br>连通子图，也就是所谓的极小连通子图 </p><h2 id="2、案例-2"><a href="#2、案例-2" class="headerlink" title="2、案例"></a>2、案例</h2><p><img src="img%5C%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%951.png" alt=""></p><p>1) 有胜利乡有7 个村庄(A, B, C, D, E, F, G) ，现在需要修路把 7 个村庄连通<br>2) 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里<br>3) 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?<br>思路: 将 10 条边，连接即可，但是总的里程数不是最小.<br>正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少.</p><h2 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h2><p>1) 设 G=(V,E)是连通网，T=(U,D)是最小生成树，V,U 是顶点集合，E,D 是边的集合<br>2) 若从顶点 u 开始构造最小生成树，则从集合 V 中取出顶点 u 放入集合 U 中，标记顶点v 的visited[u]=1<br>3) 若集合 U 中顶点 ui 与集合 V-U 中的顶点 vj 之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将<br>顶点 vj 加入集合 U 中，将边（ui,vj）加入集合 D 中，标记 visited[vj]=1<br>4) 重复步骤②，直到 U 与 V 相等，即所有顶点都被标记为访问过，此时D 中有 n-1 条边<br>5) 提示: 单独看步骤很难理解，我们通过代码来讲解，比较好理解.<br>6) 图解普利姆算法</p><p><img src="img%5C%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%952.png" alt=""></p><h2 id="4、代码实现"><a href="#4、代码实现" class="headerlink" title="4、代码实现"></a>4、代码实现</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>prim<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrimAlgorithm</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//测试看看图是否创建ok</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">,</span><span class="token string">'D'</span><span class="token punctuation">,</span><span class="token string">'E'</span><span class="token punctuation">,</span><span class="token string">'F'</span><span class="token punctuation">,</span><span class="token string">'G'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> verxs <span class="token operator">=</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不联通</span>        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>weight<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>            <span class="token punctuation">{</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">10000</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建MGraph对象</span>        MGraph graph <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MGraph</span><span class="token punctuation">(</span>verxs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建一个MinTree对象</span>        MinTree minTree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MinTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        minTree<span class="token punctuation">.</span><span class="token function">createGraph</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> verxs<span class="token punctuation">,</span> data<span class="token punctuation">,</span> weight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出</span>        minTree<span class="token punctuation">.</span><span class="token function">showGraph</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//测试普利姆算法</span>        minTree<span class="token punctuation">.</span><span class="token function">prim</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// </span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//创建最小生成树->村庄的图</span><span class="token keyword">class</span> <span class="token class-name">MinTree</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//创建图的邻接矩阵</span>    <span class="token comment" spellcheck="true">/**     *      * @param graph 图对象     * @param verxs 图对应的顶点个数     * @param data 图的各个顶点的值     * @param weight 图的邻接矩阵     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createGraph</span><span class="token punctuation">(</span>MGraph graph<span class="token punctuation">,</span> <span class="token keyword">int</span> verxs<span class="token punctuation">,</span> <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> weight<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> verxs<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//顶点</span>            graph<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> verxs<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                graph<span class="token punctuation">.</span>weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//显示图的邻接矩阵</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showGraph</span><span class="token punctuation">(</span>MGraph graph<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> link<span class="token operator">:</span> graph<span class="token punctuation">.</span>weight<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//编写prim算法，得到最小生成树</span>    <span class="token comment" spellcheck="true">/**     *      * @param graph 图     * @param v 表示从图的第几个顶点开始生成'A'->0 'B'->1...     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">prim</span><span class="token punctuation">(</span>MGraph graph<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//visited[] 标记结点(顶点)是否被访问过</span>        <span class="token keyword">int</span> visited<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>graph<span class="token punctuation">.</span>verxs<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//visited[] 默认元素的值都是0, 表示没有访问过</span><span class="token comment" spellcheck="true">//        for(int i =0; i &lt;graph.verxs; i++) {</span><span class="token comment" spellcheck="true">//            visited[i] = 0;</span><span class="token comment" spellcheck="true">//        }</span>        <span class="token comment" spellcheck="true">//把当前这个结点标记为已访问</span>        visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//h1 和 h2 记录两个顶点的下标</span>        <span class="token keyword">int</span> h1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> h2 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minWeight <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将 minWeight 初始成一个大数，后面在遍历过程中，会被替换</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> graph<span class="token punctuation">.</span>verxs<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//因为有 graph.verxs顶点，普利姆算法结束后，有 graph.verxs-1边</span>            <span class="token comment" spellcheck="true">//这个是确定每一次生成的子图 ，和哪个结点的距离最近</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> graph<span class="token punctuation">.</span>verxs<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// i结点表示被访问过的结点</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span> graph<span class="token punctuation">.</span>verxs<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//j结点表示还没有访问过的结点</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> graph<span class="token punctuation">.</span>weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minWeight<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//替换minWeight(寻找已经访问过的结点和未访问过的结点间的权值最小的边)</span>                        minWeight <span class="token operator">=</span> graph<span class="token punctuation">.</span>weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                        h1 <span class="token operator">=</span> i<span class="token punctuation">;</span>                        h2 <span class="token operator">=</span> j<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//找到一条边是最小</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"边&lt;"</span> <span class="token operator">+</span> graph<span class="token punctuation">.</span>data<span class="token punctuation">[</span>h1<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span> graph<span class="token punctuation">.</span>data<span class="token punctuation">[</span>h2<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"> 权值:"</span> <span class="token operator">+</span> minWeight<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将当前这个结点标记为已经访问</span>            visited<span class="token punctuation">[</span>h2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//minWeight 重新设置为最大值 10000</span>            minWeight <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MGraph</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> verxs<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//表示图的节点个数</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存放结点数据</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> weight<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//存放边，就是我们的邻接矩阵</span>    <span class="token keyword">public</span> <span class="token function">MGraph</span><span class="token punctuation">(</span><span class="token keyword">int</span> verxs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>verxs <span class="token operator">=</span> verxs<span class="token punctuation">;</span>        data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>verxs<span class="token punctuation">]</span><span class="token punctuation">;</span>        weight <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>verxs<span class="token punctuation">]</span><span class="token punctuation">[</span>verxs<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>参考：</p><p><a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html" target="_blank" rel="noopener">https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html</a></p><p>尚硅谷韩顺平图解Java数据结构和算法.pdf</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法#1007 、行相等的最少多米诺旋转</title>
      <link href="/2019/04/01/LeetCode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%951007%E8%A1%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%9A%E7%B1%B3%E8%AF%BA%E6%97%8B%E8%BD%AC/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%951007%E8%A1%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%9A%E7%B1%B3%E8%AF%BA%E6%97%8B%E8%BD%AC/"/>
      <url>/2019/04/01/LeetCode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%951007%E8%A1%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%9A%E7%B1%B3%E8%AF%BA%E6%97%8B%E8%BD%AC/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%951007%E8%A1%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%9A%E7%B1%B3%E8%AF%BA%E6%97%8B%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="1、题目"><a href="#1、题目" class="headerlink" title="1、题目"></a>1、题目</h1><p>在一排多米诺骨牌中，A[i] 和 B[i] 分别代表第 i 个多米诺骨牌的上半部分和下半部分。（一个多米诺是两个从 1 到 6 的数字同列平铺形成的 —— 该平铺的每一半上都有一个数字。）</p><p>我们可以旋转第 i 张多米诺，使得 A[i] 和 B[i] 的值交换。</p><p>返回能使 A 中所有值或者 B 中所有值都相同的最小旋转次数。</p><p>如果无法做到，返回 -1.</p><p>示例 1：</p><p><img src="img%5C1.png" alt=""></p><p>输入：A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]<br>输出：2<br>解释：<br>图一表示：在我们旋转之前， A 和 B 给出的多米诺牌。<br>如果我们旋转第二个和第四个多米诺骨牌，我们可以使上面一行中的每个值都等于 2，如图二所示。</p><p>示例 2：<br>输入：A = [3,5,1,2,3], B = [3,6,3,3,4]<br>输出：-1<br>解释：<br>在这种情况下，不可能旋转多米诺牌使一行的值相等。</p><p>提示：<br>1 &lt;= A[i], B[i] &lt;= 6<br>2 &lt;= A.length == B.length &lt;= 20000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-domino-rotations-for-equal-row" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-domino-rotations-for-equal-row</a></p><h1 id="2、所用算法介绍"><a href="#2、所用算法介绍" class="headerlink" title="2、所用算法介绍"></a>2、所用算法介绍</h1><p>1) 贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而<br>希望能够导致结果是最好或者最优的算法</p><p>2) 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</p><h1 id="3、解题"><a href="#3、解题" class="headerlink" title="3、解题"></a>3、解题</h1><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> B<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> min_a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> min_b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录要反转的次数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> target <span class="token operator">&amp;&amp;</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//如果没有一个等于target，那就失败，直接返回-1</span>              <span class="token comment" spellcheck="true">//经过上面的if判断过滤，则后面每一对中至少有一个==target，只要找出每个数组中不等于target的，即需要翻转的</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> target<span class="token punctuation">)</span> min_a<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里判断其实是A[i]!=target&amp;&amp;B[i]==target</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>B<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> target<span class="token punctuation">)</span> min_b<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里判断其实是B[i]!=target&amp;&amp;A[i]==target</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>min_a<span class="token punctuation">,</span> min_b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//能成功使得一行相同，返回翻转次数最小的</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果想要任何一行的数字都相同，则这个数字必须出现在每一对里，</span>    <span class="token comment" spellcheck="true">//要么在A里要么在B里，既然必须出现在每一对，那么我们就可以任取一对，我们就取第一对</span>    <span class="token comment" spellcheck="true">//即这个一列相同的数字要么是A[0]，要么是B[0]，或者不存在相同数字的一行</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDominoRotations</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> B<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> B<span class="token punctuation">,</span> A<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里切记B为第一个，A为第二个</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>min<span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> B<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> min<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//如果这对数相等，则也不用求B[0]时的情况，直接返回，无论成不成功</span>       <span class="token comment" spellcheck="true">//如果target是A[0]时，且不等于-1，也直接返回，且不必比较和target是b[0]时，哪个更小，因为肯定相等</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">check</span><span class="token punctuation">(</span>B<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> B<span class="token punctuation">,</span> A<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果不满足上面if的要求，直接返回target是B[0]时的返回值，不论成功与否</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeteCode刷题|动态规划（二分法、贪心、双指针）|#392判断子序列</title>
      <link href="/2019/03/23/LeetCode/LeteCode%E5%88%B7%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%E5%88%86%E6%B3%95%E3%80%81%E8%B4%AA%E5%BF%83%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89392%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2019/03/23/LeetCode/LeteCode%E5%88%B7%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%E5%88%86%E6%B3%95%E3%80%81%E8%B4%AA%E5%BF%83%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89392%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1、题目"><a href="#1、题目" class="headerlink" title="1、题目"></a>1、题目</h1><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p><p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p><p>示例 1:<br>s = “abc”, t = “ahbgdc”</p><p>返回 true.</p><p>示例 2:<br>s = “axc”, t = “ahbgdc”</p><p>返回 false.</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/is-subsequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/is-subsequence</a></p><h1 id="2、所用算法介绍"><a href="#2、所用算法介绍" class="headerlink" title="2、所用算法介绍"></a>2、所用算法介绍</h1><h2 id="1-、介绍"><a href="#1-、介绍" class="headerlink" title="1)、介绍"></a>1)、介绍</h2><p>1) 动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解<br>的处理算法<br>2) 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这<br>些子问题的解得到原问题的解。<br>3) 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子<br>阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )<br>4) 动态规划可以通过填表的方式来逐步推进，得到最优解.</p><h2 id="2-、适用情况"><a href="#2-、适用情况" class="headerlink" title="2)、适用情况"></a>2)、适用情况</h2><p>能采用动态规划求解的问题的一般要具有3个性质：</p><p>（1）最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p><p>（2） 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p><p>（3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p><h2 id="3-、基本步骤"><a href="#3-、基本步骤" class="headerlink" title="3)、基本步骤"></a>3)、基本步骤</h2><p>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p><p>  初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</p><p>​            图1 动态规划决策过程示意图</p><p>  (1)<strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p><p>  (2)<strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p><p>  (3)<strong>确定决策并写出状态转移方程</strong>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p><p>  (4)<strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p><p>   一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p><p>实际应用中可以按以下几个简化的步骤进行设计：</p><p>   （1）分析最优解的性质，并刻画其结构特征。</p><p>   （2）递归的定义最优解。</p><p>   （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</p><p>   （4）根据计算最优值时得到的信息，构造问题的最优解</p><h1 id="3、动态规划法代码实现"><a href="#3、动态规划法代码实现" class="headerlink" title="3、动态规划法代码实现"></a>3、动态规划法代码实现</h1><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//将两个字符串都转为字符数组</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars01 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars02 <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> chars01<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> chars02<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> temp<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>chars01<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> chars02<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> j<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                temp <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="4、其他算法实现"><a href="#4、其他算法实现" class="headerlink" title="4、其他算法实现"></a>4、其他算法实现</h1><h2 id="1）二分法"><a href="#1）二分法" class="headerlink" title="1）二分法"></a>1）二分法</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>     List<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tl<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tl<span class="token punctuation">[</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">check</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">check</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            c <span class="token operator">=</span> <span class="token function">bs</span><span class="token punctuation">(</span>tl<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">bs</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> tl<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tail <span class="token operator">=</span> tl<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>head <span class="token operator">+</span> tail<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>tail <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> tl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>head <span class="token operator">&lt;</span> tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>tl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>                tail <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>tl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">&lt;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>                head <span class="token operator">=</span> mid<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>tl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> tl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> tl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>head <span class="token operator">+</span> tail<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> tl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="2）贪心算法"><a href="#2）贪心算法" class="headerlink" title="2）贪心算法"></a>2）贪心算法</h2><p>从s中依次取出一个字符，到t中去查找，记录出现的位置；<br>s中取出下一个字符，从上次出现位置的下一个开始查找，<br>直到s中的字符全部扫描完成</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将两个字符串都转为字符数组</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars01 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars02 <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//从t查找的索引初始值为0,search函数返回更新index值</span>    <span class="token comment" spellcheck="true">//因为后面需要+1，所以这里index取-1</span>    <span class="token comment" spellcheck="true">//每次从上次查询返回索引值的下一个位置开始</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>chars01<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">char</span> target<span class="token operator">=</span>chars01<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">==</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        index<span class="token operator">=</span><span class="token function">search</span><span class="token punctuation">(</span>chars02<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">==</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//这里加if是为了特殊情况，s="a",t="b",search方法之后返回-2，上一个else中index=-2之后，for循环直接结束了，没来得及判断if(index==-2)</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//因为是无序数组，所以采用线性查找算法 index是查找的起点</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">,</span><span class="token keyword">char</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>index<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果循环结束还没有返回索引值，说明没有返回-1</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以继续改进：</p><p>遍历扫描chars02的时候，不必遍历到最后。如当我们搜索chars01=“abcde”中的c时，就可以只搜寻到chars02的倒数第三个数，只要我们在每次search之后并返回值不是-2的时候记录此时chars01已被搜寻到的字符串个数k，并将k传入到search方法中，然后search方法中for循环的中值条件就可以改为i&lt;arr.length-（chars.length-k）</p><h2 id="3）双指针法"><a href="#3）双指针法" class="headerlink" title="3）双指针法"></a>3）双指针法</h2><ul><li><p>可以知道的是，当扫描s中的第k个字符时，假如它在t字符串中的第i位和第j位都出现过(i &lt; j)，那么我们从左到右扫描到第i位时，就认为已经找到了s中第k个字符。因为i后面有更多的备选字符可以用来找s中的剩余字符。也就是说，我们在t中找字符时，是严格不回溯的。这个问题可以使用双指针解决。</p></li><li><p>初始化指针i，j为0，分别指向s和j的第0个字符，在t中找到s[i]字符后，i++试图找下一个字符。</p></li><li><p>若最后i到达s末尾，则说明找到了该字符串</p></li></ul><p>这个算法比上一种算法时间要长，因为，即使s中间已经有字符不在t存在了，依然没有停止遍历寻找。因为他是通过判断最终能够匹配的个数是否等于s长度。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars01 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars02 <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>chars01<span class="token punctuation">.</span>length<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;</span>chars02<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>chars01<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>chars02<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果相等则两个指针都向后移</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果不相等，则移动chars02的指针，直到找到或遍历完还没有找到</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//确认chars01最终有没有遍历到结尾</span>           <span class="token keyword">return</span> i<span class="token operator">==</span>chars01<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>910 最小差值</title>
      <link href="/2019/03/21/LeetCode/910%20%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC/910%20%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC/"/>
      <url>/2019/03/21/LeetCode/910%20%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC/910%20%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="1、题目"><a href="#1、题目" class="headerlink" title="1、题目"></a>1、题目</h1><p>给定一个整数数组 A，对于每个整数 A[i]，我们可以选择 x = -K 或是 x = K，并将 x 加到 A[i] 中。<br>在此过程之后，我们得到一些数组 B。<br>返回 B 的最大值和 B 的最小值之间可能存在的最小差值。</p><p>示例 1：</p><p>输入：A = [1], K = 0<br>输出：0<br>解释：B = [1]<br>示例 2：</p><p>输入：A = [0,10], K = 2<br>输出：6<br>解释：B = [2,8]<br>示例 3：</p><p>输入：A = [1,3,6], K = 3<br>输出：3<br>解释：B = [4,6,3]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/smallest-range-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-range-ii</a></p><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt;= 10000</code></li><li><code>0 &lt;= K &lt;= 10000</code></li></ol><h1 id="2、解题思路"><a href="#2、解题思路" class="headerlink" title="2、解题思路"></a>2、解题思路</h1><p>我们从示例中就可以看出，要想获得最小差值，就需要对数组A中较小的值加K，较大的值减K。这就可以尽可能地减小他们之间的差值。因此，我们先将原数组先排一下序。</p><p><img src="img%5C1.png" alt=""></p><p>然后，我们以一个元素为界，将较小值加K，将较大值减K。黑色是原数组，红色是新数组：</p><p><img src="img%5C2.png" alt=""></p><p>K值大小不同是，新数组的最值有所区别，当 K 很小的时候，就是下面的情况，显然红色的新数组里，最大值是 D，最小值是 A。<br>最小差值产生于分界处，最大差值产生于边界处。</p><p><img src="img%5C3.png" alt=""></p><p>当 K 很大的时候，就是下面的情况，显然红色新数组里，最大值是 B，最小值是 C。<br>最小差值产生于边界处，最大差值产生于分界处。</p><p><img src="img%5C4.png" alt=""></p><p>当我们选择在 i 这一点“切一刀”的时候，也就是 A[0] ~ A[i] 的元素都上移，A[i + 1] ~ A[A.length - 1] 的元素都下移。<br>此时 B 点的值是 A[i] + K，D 点的值是 A[A.length - 1] - K。<br>新数组的最大值要么是 B 点要么是 D 点，也就是说新数组的最大值是 Max(A[i] + K, A[A.length - 1] - K)。</p><p>同样道理，此时 A 点的值是 A[0] + K，C 点的值是 A[i + 1] - K。<br>新数组的最小值要么是 A 点要么是 C 点，也就是说新数组的最小值是 Min(A[0] + K, A[i + 1] - K)。</p><p>因此，题目需要的“新数组的最大值和最小值的差值”，就是 Max(A[i] + K, A[A.length - 1] - K) - Min(A[0] + K, A[i + 1] - K)。</p><p>K 的值是题目给出的固定值，因此如果我们想让上面这个算式的结果尽可能小的话，就要靠改变 i 的值，也就是思考究竟要在哪里“切这一刀”。因此我们挨个遍历一下所有可能的 i 的值，然后取上面算式的最小值即可。</p><p>作者：user83429423<br>链接：<a href="https://leetcode-cn.com/problems/smallest-range-ii/solution/tai-nan-liao-zhi-neng-hua-tu-ping-zhi-jue-by-user8/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-range-ii/solution/tai-nan-liao-zhi-neng-hua-tu-ping-zhi-jue-by-user8/</a><br>来源：力扣（LeetCode）</p><h1 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h1><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">smallestRangeII</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n<span class="token operator">=</span>A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> min<span class="token operator">=</span>A<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始的min往大了取</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> high<span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>K<span class="token punctuation">,</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>K<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最大点要么是左段的最右值，要么是右端的最右值</span>            <span class="token keyword">int</span> low<span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>K<span class="token punctuation">,</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>K<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最小点要么是左段的最左值，要么是右段的最右值</span>            min<span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span>high<span class="token operator">-</span>low<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>时间复杂度：O(N \log N)<em>O</em>(<em>N</em>log<em>N</em>)，其中 N<em>N</em> 是 <code>A</code> 的长度。</li><li>空间复杂度：O(1)<em>O</em>(1)，额外空间就是自带排序算法的空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客</title>
      <link href="/2018/05/23/%E5%85%B6%E4%BB%96/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/05/23/%E5%85%B6%E4%BB%96/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="1、安装Node-js"><a href="#1、安装Node-js" class="headerlink" title="1、安装Node.js"></a>1、安装Node.js</h1><p>下载对应你系统的Node.js版本:<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p><p><img src="img/%E5%AE%89%E8%A3%851.png" alt=""></p><p><img src="img/%E5%AE%89%E8%A3%852.png" alt=""></p><p><img src="img/%E5%AE%89%E8%A3%853.png" alt=""></p><p><img src="img/%E5%AE%89%E8%A3%854.png" alt=""></p><p><img src="img/image-20200701212706471.png" alt="image-20200701212706471"></p><p>打开终端，测试是否安装成功。</p><h1 id="2、安装hexo"><a href="#2、安装hexo" class="headerlink" title="2、安装hexo"></a>2、安装hexo</h1><p>使用npm（nodejs的包管理工具，类似后端的maven）安装hexo</p><pre><code>npm install hexo -g</code></pre><p>检查是否安装成功</p><pre><code>hexo -v;</code></pre><p><img src="img/image-20200701213112830.png" alt="image-20200701213112830"></p><h1 id="3、下载博客模板"><a href="#3、下载博客模板" class="headerlink" title="3、下载博客模板"></a>3、下载博客模板</h1><p>生成博客文件夹，init 后面就是你的博客文件夹</p><pre><code>hexo init jiangcheng</code></pre><p>安装成功后会显示：</p><p><img src="img/image-20200701213538102.png" alt="image-20200701213538102"></p><p>进入博客文件夹，启动博客，检查是否可以正常启动</p><p><img src="img/image-20200701213824989.png" alt="image-20200701213824989"></p><p>浏览器输入<a href="http://localhost:4000。展示默认主题（landscape）">http://localhost:4000。展示默认主题（landscape）</a></p><p><img src="img/image-20200701213940469.png" alt="image-20200701213940469"></p><h1 id="4、下载主题"><a href="#4、下载主题" class="headerlink" title="4、下载主题"></a>4、下载主题</h1><p>切换到主题文件夹</p><pre><code>cd themes</code></pre><p>在当前目录下通过git下载我们需要的主题代码，github下载可能有点慢，出现EOF 失败就多试几次</p><pre><code>git clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre><p><img src="img/image-20200701214330596.png" alt="image-20200701214330596"></p><h1 id="5、配置主题"><a href="#5、配置主题" class="headerlink" title="5、配置主题"></a>5、配置主题</h1><p>切换到博客根目录（jiangcheng），打开_config.yml（博客的配置文件）。注意yml文件对格式要求很<br>高，也就意味着，所有属性名后的冒号后面必须有一个空格</p><ol><li><p>找到theme，将后面的landscape，修改为下载的主题的文件夹名称hexo-theme-matery</p><p><img src="img/image-20200701214549769.png" alt="image-20200701214549769"></p></li><li><p>重启服务，部署成功</p></li></ol><pre><code>hexo s</code></pre><p><img src="img/image-20200701221005402.png" alt="image-20200701221005402"></p><h1 id="6、修改主题配置"><a href="#6、修改主题配置" class="headerlink" title="6、修改主题配置"></a>6、修改主题配置</h1><h2 id="1）配置菜单导航"><a href="#1）配置菜单导航" class="headerlink" title="1）配置菜单导航"></a>1）配置菜单导航</h2><ol><li>打开主题文件夹（/jiangcheng/themes/hexo-theme-matery）。</li><li>找到_config.yml（注意：此配置文件为主题配置文件，修改主题相关的信息，区分根目录下的配<br>置文件）</li><li>根据注释，修改配置主题配置文件。（更多主题配置提示可参考主题下的README.md）</li><li>联系我（contact）不要的话可以注释掉</li></ol><p><img src="img/image-20200701225425797.png" alt="image-20200701225425797"></p><h2 id="2）新建分类（categories）"><a href="#2）新建分类（categories）" class="headerlink" title="2）新建分类（categories）"></a>2）新建分类（categories）</h2><pre><code>hexo new page categories</code></pre><p>新建之后，在根目录source 下有个categories目录，打开修改里面的index.md<br>修改为：</p><pre class=" language-java"><code class="language-java">title<span class="token operator">:</span> categoriesdate<span class="token operator">:</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">21</span><span class="token operator">:</span><span class="token number">52</span>type<span class="token operator">:</span> <span class="token string">"categories"</span>layout<span class="token operator">:</span> <span class="token string">"categories"</span></code></pre><h2 id="3）新建标签（tag）"><a href="#3）新建标签（tag）" class="headerlink" title="3）新建标签（tag）"></a>3）新建标签（tag）</h2><pre><code>hexo new page tags</code></pre><p>新建之后，在根目录source 下有个tags目录，打开修改里面的index.md<br>修改为：</p><pre class=" language-java"><code class="language-java">title<span class="token operator">:</span> tagsdate<span class="token operator">:</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">23</span><span class="token operator">:</span><span class="token number">06</span>type<span class="token operator">:</span> <span class="token string">"tags"</span>layout<span class="token operator">:</span> <span class="token string">"tags"</span></code></pre><h2 id="4）新建关于我页面（about"><a href="#4）新建关于我页面（about" class="headerlink" title="4）新建关于我页面（about)"></a>4）新建关于我页面（about)</h2><pre><code>hexo new page &quot;about&quot;</code></pre><p>新建之后，在根目录source 下有个tags目录，打开修改里面的index.md<br>修改为：</p><pre class=" language-java"><code class="language-java">title<span class="token operator">:</span> aboutdate<span class="token operator">:</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">38</span><span class="token operator">:</span><span class="token number">57</span>type<span class="token operator">:</span> <span class="token string">"about"</span>layout<span class="token operator">:</span> <span class="token string">"about"</span></code></pre><h2 id="5）新建一篇名为test的博客"><a href="#5）新建一篇名为test的博客" class="headerlink" title="5）新建一篇名为test的博客"></a>5）新建一篇名为test的博客</h2><p>（其实就是在根目录下的source/_post文件夹下新增一<br>个Test.md文件。后续可以直接把md文件放进去，注意在文章最上面要加头信<br>息）</p><pre><code>hexo new Test</code></pre><p>打开Test.md，修改头信息</p><pre class=" language-java"><code class="language-java">title<span class="token operator">:</span> Testdate<span class="token operator">:</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">26</span><span class="token operator">:</span><span class="token number">40</span>tags<span class="token operator">:</span>    <span class="token operator">-</span> tag1    <span class="token operator">-</span> tag2categories<span class="token operator">:</span>category1这是第一篇博客</code></pre><blockquote><p>title 表示文章名称<br>date 表示发布时间，可随意时间<br>tags 表示标签，可以随意添加，多个换行并在前面加 -<br>categories 表示分类，可以随意添加，多个换行并在前面加 -</p></blockquote><h1 id="7、发布到github"><a href="#7、发布到github" class="headerlink" title="7、发布到github"></a>7、发布到github</h1><p>首先在 github下新建一个公开的项目。可以参考<a href="http://www.luyixian.cn/news_show_9986.aspx" target="_blank" rel="noopener">http://www.luyixian.cn/news_show_9986.aspx</a></p><p>打开根目录下的_config.yml，修改最下面的deploy</p><pre class=" language-java"><code class="language-java"># Deployment ## Docs<span class="token operator">:</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>hexo<span class="token punctuation">.</span>io<span class="token operator">/</span>docs<span class="token operator">/</span>deployment<span class="token punctuation">.</span>htmldeploy<span class="token operator">:</span>type<span class="token operator">:</span> git #部署类型，使用githubrepository<span class="token operator">:</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span><span class="token punctuation">{</span>Username<span class="token punctuation">}</span><span class="token operator">/</span><span class="token punctuation">{</span>Username<span class="token punctuation">}</span><span class="token punctuation">.</span>github<span class="token punctuation">.</span>io<span class="token punctuation">.</span>git #部署的仓库的SSH#上述方法失效时使用在git bash中重试并可使用一下方法#repository<span class="token operator">:</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token punctuation">{</span>Username<span class="token punctuation">}</span><span class="token operator">:</span><span class="token punctuation">{</span>password<span class="token punctuation">}</span><span class="token annotation punctuation">@github</span><span class="token punctuation">.</span>com<span class="token operator">/</span><span class="token punctuation">{</span>Username<span class="token punctuation">}</span><span class="token operator">/</span><span class="token punctuation">{</span>Username<span class="token punctuation">}</span><span class="token punctuation">.</span>github<span class="token punctuation">.</span>io<span class="token punctuation">.</span>gitbranch<span class="token operator">:</span> master #部署分支， 一般使用master主分支message<span class="token operator">:</span> update #默认类型</code></pre><p>进行部署</p><pre><code>hexo d</code></pre><p>出现INFO Deploy done: git 表示发布成功<br>使用浏览器访问 (username).github.io ，表示部署成功</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collection集合类和Map接口各实现类详解</title>
      <link href="/2018/05/23/Java%E5%9F%BA%E7%A1%80/Collection%E9%9B%86%E5%90%88%E7%B1%BB%E5%92%8CMap%E6%8E%A5%E5%8F%A3%E5%90%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E8%AF%A6%E8%A7%A3/Collection%E9%9B%86%E5%90%88%E7%B1%BB%E5%92%8CMap%E6%8E%A5%E5%8F%A3%E5%90%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/05/23/Java%E5%9F%BA%E7%A1%80/Collection%E9%9B%86%E5%90%88%E7%B1%BB%E5%92%8CMap%E6%8E%A5%E5%8F%A3%E5%90%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E8%AF%A6%E8%A7%A3/Collection%E9%9B%86%E5%90%88%E7%B1%BB%E5%92%8CMap%E6%8E%A5%E5%8F%A3%E5%90%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、集合概述"><a href="#一、集合概述" class="headerlink" title="一、集合概述"></a>一、集合概述</h1><ul><li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有啥区别呢？</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><p>Java的集合类是一些非常实用的工具类，主要用于存储和装载数据 (包括对象)，因此，Java的集合类也被成为容器。在Java中，所有的集合类都位于java.util包下，这些集合类主要是基于两个根接口派生而来，它们就是 <strong>Collection</strong>和 <strong>Map</strong>。</p><p>首先我要说明的是Map不属于Collection接口。</p><p>List、Set和Map区别：<br>List 和 Set 是存储单列数据的集合，Map 是存储键和值这样的双列数据的集合；List 中存储的数据是有顺序，并<br>且允许重复；Map 中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的，Set 中存储的数据是无<br>序的，且不允许有重复，但元素在集合中的位置由元素的 hashcode 决定，位置是固定的（Set 集合根据 hashcode 来进行数据的存储，所以位置是固定的，但是位置不是用户可以控制的，所以对于用户来说 set 中的元素还是无序的）；</p><h1 id="二、Collection接口"><a href="#二、Collection接口" class="headerlink" title="二、Collection接口"></a>二、Collection接口</h1><p>Collection集合框架图如下：</p><p><img src="img/collection.png" alt=""></p><p>（图片摘自：<a href="https://www.cnblogs.com/janson071/p/9663569.html）" target="_blank" rel="noopener">https://www.cnblogs.com/janson071/p/9663569.html）</a></p><p>Collection派生出三个子接口，Set代表不可重复的无序集合、List代表可重复的有序集合、Queue是java提供的队列实现，通过它们不断的扩展出很多的集合类。</p><h2 id="2-1、Collection-常用功能"><a href="#2-1、Collection-常用功能" class="headerlink" title="2.1、Collection 常用功能"></a>2.1、Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li><li><code>public Iterator&lt;E&gt; iterator()</code> 获取迭代器</li></ul><p>还有一些操作整个集合的方法：</p><p><code>boolean containsAll(Collection&lt;?&gt; c)</code>是否包含指定集合 c 的全部元素</p><p><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>添加集合 c 中所有的元素到本集合中，如果集合有改变就返回 true</p><p><code>boolean removeAll(Collection&lt;?&gt; c)</code>删除本集合中和 c 集合中一致的元素，如果集合有改变就返回 true</p><p><code>boolean retainAll(Collection&lt;?&gt; c)</code>保留本集合中 c 集合中两者共有的，如果集合有改变就返回 true</p><p><code>void clear()</code>删除所有元素</p><p>方法演示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collection<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo1Collection</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建集合对象 </span>        <span class="token comment" spellcheck="true">// 使用多态形式</span>        Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> coll <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用方法</span>        <span class="token comment" spellcheck="true">// 添加功能  boolean  add(String s)</span>        coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"小李广"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"扫地僧"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"石破天"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>coll<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// boolean contains(E e) 判断o是否在集合中存在</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"判断  扫地僧 是否在集合中"</span><span class="token operator">+</span>coll<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"扫地僧"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//boolean remove(E e) 删除在集合中的o元素</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除石破天："</span><span class="token operator">+</span>coll<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"石破天"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"操作之后集合中元素:"</span><span class="token operator">+</span>coll<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// size() 集合中有几个元素</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"集合中有"</span><span class="token operator">+</span>coll<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"个元素"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Object[] toArray()转换成一个Object数组</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objects <span class="token operator">=</span> coll<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历数组</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> objects<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>objects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// void  clear() 清空集合</span>        coll<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"集合中内容为："</span><span class="token operator">+</span>coll<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// boolean  isEmpty()  判断是否为空</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>coll<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="2-2、List接口"><a href="#2-2、List接口" class="headerlink" title="2.2、List接口"></a>2.2、List接口</h2><h3 id="2-2-1、概述"><a href="#2-2-1、概述" class="headerlink" title="2.2.1、概述"></a>2.2.1、概述</h3><p>List是单列集合的一个重要分治，习惯性地会将实现了List接口的对象称为List结合。</p><p>2.2.1.1、List集合特点：</p><ul><li>它是一个元素存取<strong>有序</strong>的集合，即元素的存入顺序和取出顺序一致。</li><li>它是一个带有<strong>索引</strong>的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有<strong>重复</strong>的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ul><p>2.2.1.2、List接口方法</p><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建List集合对象</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 往 尾部添加 指定元素</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"图图"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"小美"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"不高兴"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// add(int index,String s) 往指定位置添加</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"没头脑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// String remove(int index) 删除指定位置元素  返回被删除元素</span>        <span class="token comment" spellcheck="true">// 删除索引位置为2的元素 </span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除索引位置为2的元素"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// String set(int index,String s)</span>        <span class="token comment" spellcheck="true">// 在指定位置 进行 元素替代（改） </span>        <span class="token comment" spellcheck="true">// 修改指定位置元素</span>        list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"三毛"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// String get(int index)  获取指定位置元素</span>        <span class="token comment" spellcheck="true">// 跟size() 方法一起用  来 遍历的 </span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//还可以使用增强for</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String string <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2.2.1.3、List的三个子类的特点</p><ul><li>ArrayList 底层结构是数组,底层查询快,增删慢。</li><li>LinkedList 底层结构是链表型的,增删快,查询慢。</li><li>voctor 底层结构是数组 线程安全的,增删慢,查询慢。</li></ul><h3 id="2-2-2、ArrayList集合类"><a href="#2-2-2、ArrayList集合类" class="headerlink" title="2.2.2、ArrayList集合类"></a>2.2.2、ArrayList集合类</h3><p>ArrayList 底层结构是数组,底层查询快,增删慢。</p><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p><p>ArrayList是List接口的实现类，一种大小可变数组，随着元素的增多，容量会自动扩充，默认初始容量值是10，也可以自己指定初始容量</p><p>（1）采用的数据结构：数组<br>（线性表：数组、链表、队列、栈<br>非线性表：二叉树、堆、图等）</p><p>（2）ArrayList特点：</p><ul><li>ArrayList底层使用了Object的数组作为容器去存储数据</li><li>ArrayList 提供了使用索引的随意访问数据</li><li>ArrayList 是线程非安全的，效率较高，查询速度高</li></ul><p>（3）ArrayList优点：<br>查询速度快<br>ArrayList缺点：<br>新增和删除元素比较慢</p><p>（4）查询速度快的原因：<br>ArrayList底层是数组实现的，根据下标查询，不需要比较，查询方式为，首地址+（元素长度＊下标），基于这个位置读取相应的字节数，所以非常快；</p><p>（5）新增和删除慢的原因：<br>增删会带来元素的移动，增加数据会向后移动，删除数据会向前移动，所以影响效率</p><p>（6）适用场景：<br>如果应用程序对数据有较多的随机访问使用ArrayList较好</p><p>（7）List a=new ArrayList()和 ArrayList a =new ArrayList()的区别？</p><p>List list = new ArrayList();这句创建了一个 ArrayList 的对象后把上溯到了 List。此时它是一个 List 对象了，有些<br>ArrayList 有但是 List 没有的属性和方法，它就不能再用了。而 ArrayList list=new ArrayList();创建一对象则保留了<br>ArrayList 的所有属性。 所以需要用到 ArrayList 独有的方法的时候不能用前者。实例代码如下：</p><pre><code>List list = new ArrayList();ArrayList arrayList = new ArrayList(); list.trimToSize(); //错误，没有该方法。 arrayList.trimToSize(); //ArrayList 里有该方法。</code></pre><p>（8）数组扩容</p><p>这是对ArrayList效率影响比较大的一个因素。<br>每当执行Add、AddRange、Insert、InsertRange等添加元素的方法，都会检查内部数组的容量是否不够了，如果是，它就会以当前容量的两倍来重新构建一个数组，将旧元素Copy到新数组中，然后丢弃旧数组，在这个临界点的扩容操作，应该来说是比较影响效率的。</p><p>例1：比如，一个可能有200个元素的数据动态添加到一个以默认16个元素大小创建的ArrayList中，将会经过：<br>16<em>2</em>2<em>2</em>2 = 256<br>四次的扩容才会满足最终的要求，那么如果一开始就以：<br>ArrayList List = new ArrayList( 210 );<br>的方式创建ArrayList，不仅会减少4次数组创建和Copy的操作，还会减少内存使用。</p><p>例2：预计有30个元素而创建了一个ArrayList：<br>ArrayList List = new ArrayList(30);<br>在执行过程中，加入了31个元素，那么数组会扩充到60个元素的大小，而这时候不会有新的元素再增加进来，而且有没有调用TrimSize方法，那么就有1次扩容的操作，并且浪费了29个元素大小的空间。如果这时候，用：<br>ArrayList List = new ArrayList(40);<br>那么一切都解决了。<br>所以说，正确的预估可能的元素，并且在适当的时候调用TrimSize方法是提高ArrayList使用效率的重要途径。</p><h3 id="2-2-3、LinkedList集合类"><a href="#2-2-3、LinkedList集合类" class="headerlink" title="2.2.3、LinkedList集合类"></a>2.2.3、LinkedList集合类</h3><p>LinkedList 底层结构是链表型的,增删快,查询慢。</p><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）</p><p>方法演示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedListDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span> link <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//添加元素</span>        link<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token string">"abc1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        link<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token string">"abc2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        link<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token string">"abc3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取元素</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>link<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>link<span class="token punctuation">.</span><span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 删除元素</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>link<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>link<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>link<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//判断集合是否为空</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>link<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//弹出集合中的栈顶元素</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其他1、ArrayList 和 Linkedlist 区别：<br>ArrayList 和 Vector 使用了数组的实现，可以认为 ArrayList 或者 Vector 封装了对内部数组的操作，比如向数组<br>中添加，删除，插入新的元素或者数据的扩展和重定向。<br>LinkedList 使用了循环双向链表数据结构。与基于数组的 ArrayList 相比，这是两种截然不同的实现技术，这也决<br>定了它们将适用于完全不同的工作场景。<br>LinkedList 链表由一系列表项连接而成。一个表项总是包含 3 个部分：元素内容，前驱表和后驱表，如图所示：</p><p><img src="img/image-20200701203345870.png" alt="image-20200701203345870"></p><p>在下图展示了一个包含 3 个元素的 LinkedList 的各个表项间的连接关系。在 JDK 的实现中，无论 LikedList 是否<br>为空，链表内部都有一个 header 表项，它既表示链表的开始，也表示链表的结尾。表项 header 的后驱表项便是链表<br>中第一个元素，表项 header 的前驱表项便是链表中最后一个元素。</p><p><img src="img/image-20200701203416103.png" alt="image-20200701203416103"></p><p>其他2、List a=new ArrayList()和 ArrayList a =new ArrayList()的区别</p><p>List list = new ArrayList();这句创建了一个 ArrayList 的对象后把上溯到了 List。此时它是一个 List 对象了，有些<br>ArrayList 有但是 List 没有的属性和方法，它就不能再用了。而 ArrayList list=new ArrayList();创建一对象则保留了<br>ArrayList 的所有属性。 所以需要用到 ArrayList 独有的方法的时候不能用前者。实例代码如下：</p><pre><code>1．List list = new ArrayList();2．ArrayList arrayList = new ArrayList(); 3．list.trimToSize(); //错误，没有该方法。 4．arrayList.trimToSize(); //ArrayList 里有该方法。</code></pre><p>其他3、要对集合更新操作时，ArrayList 和 LinkedList 哪个更适合</p><p>ArrayList 和 LinkedList 在性能上各有优缺点，都有各自所适用的地方，总的说来可以描述如下：<br> 1．对 ArrayList 和 LinkedList 而言，在列表末尾增加一个元素所花的开销都是固定的。对 ArrayList 而言，主要是在内部数组中增加一项，指向所添加的元素，偶 尔可能会导致对数组重新进行分配；而对 LinkedList 而言，这个开销是统一的，分配一个内部 Entry 对象。<br> 2．在 ArrayList 的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在 LinkedList 的中间插入或删除一个元素的开销是固定的。<br> 3．LinkedList 不支持高效的随机元素访问。<br> 4．ArrayList 的空间浪费主要体现在在 list 列表的结尾预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗相当的空间<br>可以这样说：当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList 会提供比较好的性能；当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元 素时,就应该使用 LinkedList 了。</p><h3 id="2-2-4、Vector"><a href="#2-2-4、Vector" class="headerlink" title="2.2.4、Vector"></a>2.2.4、Vector</h3><p>voctor 底层结构是数组 线程安全的,增删慢,查询慢。</p><p>Vector非常类似ArrayList，但是Vector是同步的，效率相对比较低</p><p>Vector实现了Serializable接口，支持序列化，实现了Cloneable接口，能被克隆，实现了RandomAccess接口，支持快速随机访问。</p><p>Vector的底层结构也是数组，但是它们对数组的扩容方式不同</p><p>当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加50%的大小，这样ArrayList就有利于节约内存空间。即Vector增长原来的一倍，ArrayList增加原来的0.5倍。</p><p>Stack栈继承于Vector，栈的存储特点是后进先出，它基于动态数组实现的一个线程安全的栈，所以栈是线程安全的</p><p>java.util.vector提供了向量类(vector)以实现类似动态数组的功能。在Java语言中没有指针的概念，但如果正确灵活地使用指针又确实可以大大提高程序的质量。比如在c,c++中所谓的“动态数组”一般都由指针来实现。为了弥补这个缺点，Java提供了丰富的类库来方便编程者使用，vector类便是其中之一。事实上，灵活使用数组也可以完成向量类的功能，但向量类中提供大量的方法大大方便了用户的使用。<br>创建了一个向量类的对象后，可以往其中<strong>随意插入不同类的对象</strong>，即不需顾及类型也不需预先选定向量的容量，并可以方便地进行查找。<strong>对于预先不知或者不愿预先定义数组大小，并且需要频繁地进行查找，插入，删除工作的情况。可以考虑使用向量类</strong>。</p><p>Vector与ArrayList的区别：</p><ul><li>Vector是线程安全的, ArrayList不是线程安全的, 这是最主要的</li><li>Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector效率低，不能与ArrayList相比。</li><li>两者都是采用线性连续空间存储元素，当空间不足时，两者的扩容方式不同。ArrayList不可以设置扩展的容量, 默认1.5倍; Vector可以设置, 默认2倍</li><li>ArrayList无参构造函数中初始量为0; Vector的无参构造函数初始容量为10</li></ul><p>向量类提供了三种构造方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token function">vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialcapacity<span class="token punctuation">,</span><span class="token keyword">int</span> capacityIncrement<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token function">vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialcapacity<span class="token punctuation">)</span></code></pre><p>使用第一种方法系统会自动对向量进行管理，若使用后两种方法。则系统将根据参数，initialcapacity设定向量对象的容量（即向量对象可存储数据的大小），当真正存放的数据个数超过容量时。系统会扩充向量对象存储容量。<br>参数capacityincrement给定了每次扩充的扩充值。当capacityincrement为0的时候，则没次扩充一倍，利用这个功能可以优化存储。</p><p>在Vector类中提供了各种方法方便用户的使用：<br>很多方法都加入了synchronized同步语句，来保证线程安全。</p><p>插入功能：</p><p>（1）public final synchronized void adddElement(Object obj)<br>将obj插入向量的尾部。obj可以是任何类型的对象。对同一个向量对象，亦可以在其中插入不同类的对象。但插入的应是对象而不是数值，所以插入数值时要注意将数组转换成相应的对象。<br>例如：要插入整数1时，不要直接调用v1.addElement(1),正确的方法为： Vector v1 = new Vector();<br>Integer integer1 = new Integer(1); v1.addElement(integer1);</p><p>(2)public final synchronized void setElementAt(Object obj,int index)<br>将index处的对象设置成obj，原来的对象将被覆盖。</p><p>(3)public final synchronized void insertElementAt(Object obj,int<br>index) 在index指定的位置插入obj，原来对象以及此后的对象依次往后顺延。</p><p>删除功能：</p><p>(1)public final synchronized void removeElement(Object obj)<br>从向量中删除obj,若有多个存在，则从向量头开始试，删除找到的第一个与obj相同的向量成员。 (2)public final<br>synchronized void removeAllElement(); 删除向量所有的对象 (3)public fianl<br>synchronized void removeElementAt(int index) 删除index所指的地方的对象<br>查询搜索功能：</p><p>(1)public final int indexOf(Object obj)<br>从向量头开始搜索obj,返回所遇到的第一个obj对应的下标，若不存在此obj,返回-1.</p><p>(2)public final synchronized int indexOf(Object obj,int index)<br>从index所表示的下标处开始搜索obj.</p><p>(3)public final int lastindexOf(Object obj) 从向量尾部开始逆向搜索obj.</p><p>(4)public final synchornized int lastIndex(Object obj,int index)<br>从index所表示的下标处由尾至头逆向搜索obj.</p><p>(5)public final synchornized firstElement() 获取向量对象中的首个obj</p><p>(6)public final synchornized Object lastElement() 获取向量对象的最后一个obj</p><h2 id="2-3、Set接口"><a href="#2-3、Set接口" class="headerlink" title="2.3、Set接口"></a>2.3、Set接口</h2><h3 id="2-3-1、概述"><a href="#2-3-1、概述" class="headerlink" title="2.3.1、概述"></a>2.3.1、概述</h3><p>存储的数据是无序的，且不允许有重复，但元素在集合中的位置由元素的 hashcode 决定，位置是固定的（Set 集合根据 hashcode 来进行数据的存储，所以位置是固定的，但是位置不是用户可以控制的，所以对于用户来说 set 中的元素还是无序的）；</p><p>它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性（== 或 eqauls）的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><p>Set集合取出元素的方式可以采用：迭代器、增强for。</p><p>Set 接口有两个实现类（HashSet：底层是由 HashMap 实现，不允许集合中有重复的值，使用该方式时需要重写 equals()和 hashCode()方法；LinkedHashSet：继承与 HashSet，同时又基于 LinkedHashMap 来进行实现，底层使用的是 LinkedHashMp）。</p><h3 id="2-3-2、List和Set的区别"><a href="#2-3-2、List和Set的区别" class="headerlink" title="2.3.2、List和Set的区别"></a>2.3.2、List和Set的区别</h3><p>List , Set 都是继承自 Collection 接口<br>List 特点：元素有放入顺序，元素可重复 ，<br>Set 特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（元素虽然无放入顺序，但是元素在set中的位置是有该元素HashCode 决定的，其位置其实是固定的，加入Set 的 Object 必须定义 equals ()方法 ，另外list 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想 要的值。） Set和List对比 Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。 List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</p><h3 id="2-3-3、HashSet类"><a href="#2-3-3、HashSet类" class="headerlink" title="2.3.3、HashSet类"></a>2.3.3、HashSet类</h3><p>HashSet数据结构：哈希表（数组+链表）</p><p>什么是哈希表呢？<br>哈希表底层使用的也是数组机制，数组中也存放对象，而这些对象往数组中存放时的位置比较特殊，当需要把这些对象给数组中存放时，那么会根据这些对象的特有数据结合相应的算法，计算出这个对象在数组中的位置，然后把这个对象存放在数组中。而这样的数组就称为哈希数组，即就是哈希表。</p><p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。</p><p><img src="img/%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt=""></p><p>看到这张图就有人要问了，这个是怎么存储的呢？</p><p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p><p><img src="img/%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p><p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p><p>创建自定义Student类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Student</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> o<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        Student student <span class="token operator">=</span> <span class="token punctuation">(</span>Student<span class="token punctuation">)</span> o<span class="token punctuation">;</span>        <span class="token keyword">return</span> age <span class="token operator">==</span> student<span class="token punctuation">.</span>age <span class="token operator">&amp;&amp;</span>               Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> student<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashSetDemo2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建集合对象   该集合中存储 Student类型对象</span>        HashSet<span class="token operator">&lt;</span>Student<span class="token operator">></span> stuSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>Student<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//存储 </span>        Student stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"于谦"</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stuSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span><span class="token punctuation">;</span>        stuSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"郭德纲"</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stuSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"于谦"</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stuSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"郭麒麟"</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stuSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Student stu2 <span class="token operator">:</span> stuSet<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stu2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>执行结果：Student <span class="token punctuation">[</span>name<span class="token operator">=</span>郭德纲<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">44</span><span class="token punctuation">]</span>Student <span class="token punctuation">[</span>name<span class="token operator">=</span>于谦<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">43</span><span class="token punctuation">]</span>Student <span class="token punctuation">[</span>name<span class="token operator">=</span>郭麒麟<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">23</span><span class="token punctuation">]</span></code></pre><h3 id="2-3-4、LinkedHashSet类"><a href="#2-3-4、LinkedHashSet类" class="headerlink" title="2.3.4、LinkedHashSet类"></a>2.3.4、LinkedHashSet类</h3><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p><p>在<strong>HashSet下面有一个子类</strong><code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p><p>演示代码如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashSetDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"bbb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"bbc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> it <span class="token operator">=</span> set<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>结果：  bbb  aaa  abc  bbc</code></pre><p>特点：</p><ul><li>具有set集合不重复的特点，同时具有可预测的迭代顺序，也就是我们插入的顺序。</li><li>是一个非线程安全的集合。如果有多个线程同时访问当前linkedhashset集合容器，并且有一个线程对当前容器中的元素做了修改，那么必须要在外部实现同步保证数据的冥等性。</li><li>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</li><li>LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</li></ul><h3 id="2-3-5、TreeSet类"><a href="#2-3-5、TreeSet类" class="headerlink" title="2.3.5、TreeSet类"></a>2.3.5、TreeSet类</h3><p>TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。</p><p>TreeSet并不是根据元素的插入顺序进行排序,而是根据元素实际值来进行排序.(可以确保元素唯一并且元素排序) TreeSet采用红黑树的数据结构对元素进行排序.</p><p>TreeSet支持两种排序方式，自然排序 和定制排序，其中自然排序为默认的排序方式(Integer类型元素自然升序)。向TreeSet中加入的应该是同一个类的对象。</p><p>TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0<br>自然排序<br>自然排序使用要排序元素的CompareTo（Object obj）方法来比较元素之间大小关系，然后将元素按照升序排列。<br>Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。<br>obj1.compareTo(obj2)方法如果返回0，则说明被比较的两个对象相等，如果返回一个正数，则表明obj1大于obj2，如果是 负数，则表明obj1小于obj2。<br>如果我们将两个对象的equals方法总是返回true，则这两个对象的compareTo方法返回应该返回0<br>定制排序<br>自然排序是根据集合元素的大小，以升序排列，如果要定制排序，应该使用Comparator接口，实现 int compare(T o1,T o2)方法</p><h2 id="2-4、Queue"><a href="#2-4、Queue" class="headerlink" title="2.4、Queue"></a>2.4、Queue</h2><p>本节转自：<a href="https://www.cnblogs.com/lemon-flm/p/7877898.html" target="_blank" rel="noopener">https://www.cnblogs.com/lemon-flm/p/7877898.html</a></p><p><strong>Queue： 基本上，一个队列就是一个先入先出（FIFO）的数据结构</strong></p><p><strong>Queue接口与List、Set同一级别，都是继承了Collection接口。LinkedList实现了Deque接 口。</strong></p><p>Queue接口与List、Set同一级别，都是继承了Collection接口。LinkedList实现了Queue接 口。Queue接口窄化了对LinkedList的方法的访问权限（即在方法中的参数类型如果是Queue时，就完全只能访问Queue接口所定义的方法 了，而不能直接访问 LinkedList的非Queue的方法），以使得只有恰当的方法才可以使用。BlockingQueue 继承了Queue接口。</p><p>队列是一种数据结构．它有两个基本操作：在队列尾部加人一个元素，和从队列头部移除一个元素就是说，队列以一种先进先出的方式管理数据，如果你试图向一个 已经满了的阻塞队列中添加一个元素或者是从一个空的阻塞队列中移除一个元索，将导致线程阻塞．在多线程进行合作时，阻塞队列是很有用的工具。工作者线程可 以定期地把中间结果存到阻塞队列中而其他工作者线线程把中间结果取出并在将来修改它们。队列会自动平衡负载。如果第一个线程集运行得比第二个慢，则第二个 线程集在等待结果时就会阻塞。如果第一个线程集运行得快，那么它将等待第二个线程集赶上来。</p><p><strong>Queue的实现</strong></p><p><strong>1、没有实现的阻塞接口的LinkedList： 实现了java.util.Queue接口和java.util.AbstractQueue接口</strong><br>　　内置的不阻塞队列： PriorityQueue 和 ConcurrentLinkedQueue<br>　　PriorityQueue 和 ConcurrentLinkedQueue 类在 Collection Framework 中加入两个具体集合实现。<br>　　PriorityQueue 类实质上维护了一个有序列表。加入到 Queue 中的元素根据它们的天然排序（通过其 java.util.Comparable 实现）或者根据传递给构造函数的 java.util.Comparator 实现来定位。<br>　　ConcurrentLinkedQueue 是基于链接节点的、线程安全的队列。并发访问不需要同步。因为它在队列的尾部添加元素并从头部删除它们，所以只要不需要知道队列的大 小，　　　　  　　ConcurrentLinkedQueue 对公共集合的共享访问就可以工作得很好。收集关于队列大小的信息会很慢，需要遍历队列。</p><p><strong>2)实现阻塞接口的：</strong><br>　　java.util.concurrent 中加入了 BlockingQueue 接口和五个阻塞队列类。它实质上就是一种带有一点扭曲的 FIFO 数据结构。不是立即从队列中添加或者删除元素，线程执行操作阻塞，直到有空间或者元素可用。<br>五个队列所提供的各有不同：<br>　　* ArrayBlockingQueue ：一个由数组支持的有界队列。<br>　　* LinkedBlockingQueue ：一个由链接节点支持的可选有界队列。<br>　　* PriorityBlockingQueue ：一个由优先级堆支持的无界优先级队列。<br>　　* DelayQueue ：一个由优先级堆支持的、基于时间的调度队列。<br>　　* SynchronousQueue ：一个利用 BlockingQueue 接口的简单聚集（rendezvous）机制。</p><p><img src="img/1182892-20171122100317930-842768608.png" alt="img"></p><p>下表显示了jdk1.5中的阻塞队列的操作：</p><p>　　<strong>add</strong>    增加一个元索           如果队列已满，则抛出一个IIIegaISlabEepeplian异常<br>　　<strong>remove</strong>  移除并返回队列头部的元素  如果队列为空，则抛出一个NoSuchElementException异常<br>　　<strong>element</strong> 返回队列头部的元素       如果队列为空，则抛出一个NoSuchElementException异常<br>　　<strong>offer</strong>    添加一个元素并返回true    如果队列已满，则返回false<br>　　<strong>poll</strong>     移除并返问队列头部的元素  如果队列为空，则返回null<br>　　<strong>peek</strong>    返回队列头部的元素       如果队列为空，则返回null<br>　　<strong>put</strong>     添加一个元素           如果队列满，则阻塞<br>　　<strong>take</strong>    移除并返回队列头部的元素   如果队列为空，则阻塞</p><p><strong>remove、element、offer 、poll、peek 其实是属于Queue接口。</strong> </p><p>阻塞队列的操作可以根据它们的响应方式分为以下三类：aad、removee和element操作在你试图为一个已满的队列增加元素或从空队列取得元素时 抛出异常。当然，在多线程程序中，队列在任何时间都可能变成满的或空的，所以你可能想使用offer、poll、peek方法。这些方法在无法完成任务时 只是给出一个出错示而不会抛出异常。</p><p>注意：poll和peek方法出错进返回null。因此，向队列中插入null值是不合法的</p><p>最后，我们有阻塞操作put和take。put方法在队列满时阻塞，take方法在队列空时阻塞。</p><p><strong>ArrayBlockingQueue</strong>在构造时需要指定容量， 并可以选择是否需要公平性，如果公平参数被设置true，等待时间最长的线程会优先得到处理（其实就是通过将ReentrantLock设置为true来 达到这种公平性的：即等待时间最长的线程会先操作）。通常，公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队 列，此队列按 FIFO（先进先出）原则对元素进行排序。</p><p><strong>PriorityBlockingQueue</strong>是一个带优先级的 队列，而不是先进先出队列。元素按优先级顺序被移除，该队列也没有上限（看了一下源码，PriorityBlockingQueue是对 PriorityQueue的再次包装，是基于堆数据结构的，而PriorityQueue是没有容量限制的，与ArrayList一样，所以在优先阻塞 队列上put时是不会受阻的。虽然此队列逻辑上是无界的，但是由于资源被耗尽，所以试图执行添加操作可能会导致 OutOfMemoryError），但是如果队列为空，那么取元素的操作take就会阻塞，所以它的检索操作take是受阻的。另外，往入该队列中的元 素要具有比较能力。</p><p><strong>DelayQueue</strong>（基于PriorityQueue来实现的）是一个存放Delayed 元素的无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且poll将返回null。当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于或等于零的值时，则出现期满，poll就以移除这个元素了。此队列不允许使用 null 元素。</p><p><img src="img/2.jpg" alt=""></p><h1 id="三、Map"><a href="#三、Map" class="headerlink" title="三、Map"></a>三、Map</h1><h2 id="3-1、关于Map"><a href="#3-1、关于Map" class="headerlink" title="3.1、关于Map"></a>3.1、关于Map</h2><h3 id="3-1-1、概述"><a href="#3-1-1、概述" class="headerlink" title="3.1.1、概述"></a>3.1.1、概述</h3><p>Map 中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的</p><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p><p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p><p><img src="img/Collection%E4%B8%8EMap.bmp" alt=""></p><ul><li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li><li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li><li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li><li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值</li></ul><h3 id="3-1-2、常用子类"><a href="#3-1-2、常用子类" class="headerlink" title="3.1.2、常用子类"></a>3.1.2、常用子类</h3><p><img src="img/Map.png" alt=""></p><p>HashMap<br>存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。它是最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为Null(多条会覆盖);允许多条记录的值为 Null。非同步的。</p><p>LinkedHashMap<br>HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.在遍历的时候会比HashMap慢。key和value均允许为空，非同步的。 </p><p>TreeMap<br>能够把它保存的记录根据键(key)排序,默认是按升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。</p><p>Hashtable<br>与 HashMap类似,不同的是:key和value的值均不允许为null;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了Hashtale在写入时会比较慢。 </p><h3 id="3-1-3、常用方法"><a href="#3-1-3、常用方法" class="headerlink" title="3.1.3、常用方法"></a>3.1.3、常用方法</h3><p>Map接口中定义了很多方法，常用的如下：</p><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>boolean containsKey(Object key)</code> 判断集合中是否包含指定的键。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><p>Map接口的方法演示</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建 map对象</span>        HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span>  map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//添加元素到集合</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"黄晓明"</span><span class="token punctuation">,</span> <span class="token string">"杨颖"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"文章"</span><span class="token punctuation">,</span> <span class="token string">"马伊琍"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"邓超"</span><span class="token punctuation">,</span> <span class="token string">"孙俪"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//String remove(String key)</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"邓超"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 想要查看 黄晓明的媳妇 是谁</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"黄晓明"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"邓超"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>tips:</p><p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p><p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p></blockquote><h3 id="3-1-4、Map遍历"><a href="#3-1-4、Map遍历" class="headerlink" title="3.1.4、Map遍历"></a>3.1.4、Map遍历</h3><h4 id="3-1-4-1、初始化数据"><a href="#3-1-4-1、初始化数据" class="headerlink" title="3.1.4.1、初始化数据"></a>3.1.4.1、初始化数据</h4><pre><code>Map&lt;String, String&gt; map = ``new` `HashMap&lt;String, String&gt;();map.put(``&quot;key1&quot;``, ``&quot;value1&quot;``);map.put(``&quot;key2&quot;``, ``&quot;value2&quot;``);</code></pre><h4 id="3-1-4-2、增强for循环遍历"><a href="#3-1-4-2、增强for循环遍历" class="headerlink" title="3.1.4.2、增强for循环遍历"></a>3.1.4.2、增强for循环遍历</h4><p>（1）使用keySet()遍历</p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">" ："</span> <span class="token operator">+</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>也叫遍历键找值方式：即通过元素中的键，获取键所对应的值</p><p>分析步骤：</p><ol><li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li><li>遍历键的Set集合，得到每一个键。</li><li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li></ol><p>代码演示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapDemo01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建Map集合对象 </span>        HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//添加元素到集合 </span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"胡歌"</span><span class="token punctuation">,</span> <span class="token string">"霍建华"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"郭德纲"</span><span class="token punctuation">,</span> <span class="token string">"于谦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"薛之谦"</span><span class="token punctuation">,</span> <span class="token string">"大张伟"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取所有的键  获取键集</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keys <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历键集 得到 每一个键</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//key  就是键</span>            <span class="token comment" spellcheck="true">//获取对应值</span>            String value <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">"的CP是："</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>遍历图解：</p><p><img src="img/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%80.bmp" alt=""></p><p>（2）使用entrySet()遍历</p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ："</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>1）Entry键值对对象</p><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p><p> 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p><ul><li><code>public K getKey()</code>：获取Entry对象中的键。</li><li><code>public V getValue()</code>：获取Entry对象中的值。</li></ul><p>在Map集合中也提供了获取所有Entry对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><p>2）遍历键值对方式</p><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p>操作步骤与图解：</p><ol><li><p>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p></li><li><p>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p></li><li><p>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>     </p></li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapDemo02</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建Map集合对象 </span>        HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 添加元素到集合 </span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"胡歌"</span><span class="token punctuation">,</span> <span class="token string">"霍建华"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"郭德纲"</span><span class="token punctuation">,</span> <span class="token string">"于谦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"薛之谦"</span><span class="token punctuation">,</span> <span class="token string">"大张伟"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取 所有的 entry对象  entrySet</span>        Set<span class="token operator">&lt;</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">>></span> entrySet <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历得到每一个entry对象</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> entrySet<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// 解析 </span>            String key <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String value <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">"的CP是:"</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>遍历图解：</p><p><img src="img/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%BA%8C.bmp" alt=""></p><blockquote><p>tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p></blockquote><h4 id="3-1-4-3、迭代器遍历"><a href="#3-1-4-3、迭代器遍历" class="headerlink" title="3.1.4.3、迭代器遍历"></a>3.1.4.3、迭代器遍历</h4><p>使用keySet()遍历</p><pre class=" language-java"><code class="language-java">Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    String key <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">"　："</span> <span class="token operator">+</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用entrySet()遍历</p><pre class=" language-java"><code class="language-java">Iterator<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> iterator <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"　："</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="3-1-4-4、HashMap遍历方式对比："><a href="#3-1-4-4、HashMap遍历方式对比：" class="headerlink" title="3.1.4.4、HashMap遍历方式对比："></a>3.1.4.4、HashMap遍历方式对比：</h4><ol><li>增强for循环使用方便，但性能较差，不适合处理超大量级的数据。</li><li>迭代器的遍历速度要比增强for循环快很多，是增强for循环的2倍左右。</li><li>使用entrySet遍历的速度要比keySet快很多，是keySet的1.5倍左右。</li></ol><h2 id="3-2、HashMap接口"><a href="#3-2、HashMap接口" class="headerlink" title="3.2、HashMap接口"></a>3.2、HashMap接口</h2><h3 id="3-2-1、HashMap的数据结构"><a href="#3-2-1、HashMap的数据结构" class="headerlink" title="3.2.1、HashMap的数据结构"></a>3.2.1、HashMap的数据结构</h3><p>数组+单链表（数组中的每个元素都是单链表的头节点）<br>使用链表的原因是解决哈希冲突的（即不同的key映射到了数组的同一位置处，就将其放入单链表中）</p><p><strong>哈希冲突</strong><br><strong>如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办</strong>？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫<strong>哈希碰撞</strong>。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了<strong>链地址法</strong>，也就是<strong>数组+链表</strong>的方式。</p><p>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。</p><p>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p><p>HashMap中的key-value都是存储在<strong>Entry数组</strong>中的。<br>Entry 实际上就是一个单向链表。这也是为什么我们说HashMap是通过拉链法解决哈希冲突的。<br>Entry 实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数。这些都是基本的读取/修改key、value值的函数。</p><p><img src="img/hashmap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt=""></p><p>简单来说，<strong>HashMap由数组+链表组成的</strong>，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，<strong>HashMap中的链表出现越少，性能才会越好。</strong></p><h3 id="3-2-2、HashMap的构造函数"><a href="#3-2-2、HashMap的构造函数" class="headerlink" title="3.2.2、HashMap的构造函数"></a>3.2.2、HashMap的构造函数</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 默认构造函数。</span><span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 指定“容量大小”的构造函数</span><span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 指定“容量大小”和“加载因子”的构造函数</span><span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 包含“子Map”的构造函数</span><span class="token function">HashMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> map<span class="token punctuation">)</span></code></pre><h3 id="3-2-3、主要方法"><a href="#3-2-3、主要方法" class="headerlink" title="3.2.3、主要方法"></a>3.2.3、主要方法</h3><p>clear()：<strong>清空HashMap</strong></p><p>containsKey() ：<strong>判断HashMap是否包含key</strong>。</p><p>containsValue() 的作用是<strong>判断HashMap是否包含“值为value”的元素</strong>。</p><p>entrySet()的作用是<strong>返回“HashMap中所有Entry的集合”，它是一个集合</strong></p><p>get() 的作用是<strong>获取key对应的value</strong></p><p>put() 的作用是<strong>对外提供接口，让HashMap对象可以通过put()将“key-value”添加到HashMap中</strong>。</p><p>putAll() 的作用是<strong>将”m”的全部元素都添加到HashMap中</strong></p><p>remove() 的作用是<strong>删除“键为key”元素</strong></p><h3 id="3-2-4、线程安全问题"><a href="#3-2-4、线程安全问题" class="headerlink" title="3.2.4、线程安全问题"></a>3.2.4、线程安全问题</h3><p>不是线程安全的；<br>如果有两个线程A和B，都进行插入数据，刚好这两条不同的数据经过哈希计算后得到的哈希码是一样的，且该位 置还没有其他的数据。所以这两个线程都会进入我在上面标记为1的代码中。假设一种情况，线程A通过if判断，该 位置没有哈希冲突，进入了if语句，还没有进行数据插入，这时候 CPU 就把资源让给了线程B，线程A停在了if语句 里面，线程B判断该位置没有哈希冲突（线程A的数据还没插入），也进入了if语句，线程B执行完后，轮到线程A执 行，现在线程A直接在该位置插入而不用再判断。这时候，你会发现线程A把线程B插入的数据给覆盖了。发生了线 程不安全情况。本来在 HashMap 中，发生哈希冲突是可以用链表法或者红黑树来解决的，但是在多线程中，可能 就直接给覆盖了。<br>上面所说的是一个图来解释可能更加直观。如下面所示，两个线程在同一个位置添加数据，后面添加的数据就覆盖 住了前面添加的。</p><p><img src="img/hashmap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A81.png" alt=""></p><p>如果上述插入是插入到链表上，如两个线程都在遍历到最后一个节点，都要在最后添加一个数据，那么后面添加数 据的线程就会把前面添加的数据给覆盖住。则</p><p><img src="img/hashmap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A82.png" alt=""></p><h3 id="3-2-5、HashMap-的扩容过程"><a href="#3-2-5、HashMap-的扩容过程" class="headerlink" title="3.2.5、HashMap  的扩容过程"></a>3.2.5、HashMap  的扩容过程</h3><p>当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值—即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦。<strong>HashMap的数组长度一定是2的次幂</strong><br>扩容( resize )就是重新计算容量，向 HashMap 对象里不停的添加元素，而 HashMap 对象内部的数组无法装载更 多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然 Java 里的数组是无法自动扩容的，方法 是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><p>HashMap hashMap=new HashMap(cap);</p><p>cap =3， hashMap 的容量为4；<br>cap =4， hashMap 的容量为4；<br>cap =5， hashMap 的容量为8；<br>cap =9， hashMap 的容量为16；<br>如果 cap 是2的n次方，则容量为 cap ，否则为大于 cap 的第一个2的n次方的数。</p><h3 id="3-2-6、HashMap1-7和1-8的区别"><a href="#3-2-6、HashMap1-7和1-8的区别" class="headerlink" title="3.2.6、HashMap1.7和1.8的区别"></a>3.2.6、HashMap1.7和1.8的区别</h3><p>在 JDK1.7 及之前的版本中， HashMap 又叫散列链表：基于一个数组以及多个链表的实现，hash值冲突的时候， 就将对应节点以链表的形式存储。<br>JDK1.8 中，当同一个hash值（ Table 上元素）的链表节点数不小于8时，将不再以单链表的形式存储了，会被 调整成一颗红黑树。这就是 JDK7 与 JDK8 中 HashMap 实现的最大区别。</p><p>其下基于 JDK1.7.0_80 与 JDK1.8.0_66 做的分析</p><p>JDK1.7中<br>使用一个 Entry 数组来存储数据，用key的 hashcode 取模来决定key会被放到数组里的位置，如果 hashcode 相 同，或者 hashcode 取模后的结果相同（ hash collision ），那么这些 key 会被定位到 Entry 数组的同一个 格子里，这些 key 会形成一个链表。<br>在 hashcode 特别差的情况下，比方说所有key的 hashcode 都相同，这个链表可能会很长，那么 put/get 操作 都可能需要遍历这个链表，也就是说时间复杂度在最差情况下会退化到 O(n)</p><p>JDK1.8中<br>使用一个 Node 数组来存储数据，但这个 Node 可能是链表结构，也可能是红黑树结构<br>如果插入的 key 的 hashcode 相同，那么这些key也会被定位到 Node 数组的同一个格子里。<br>如果同一个格子里的key不超过8个，使用链表结构存储。<br>如果超过了8个，那么会调用 treeifyBin 函数，将链表转换为红黑树。<br>那么即使 hashcode 完全相同，由于红黑树的特点，查找某个特定元素，也只需要O(log n)的开销<br>也就是说put/get的操作的时间复杂度最差只有 O(log n)<br>听起来挺不错，但是真正想要利用 JDK1.8 的好处，有一个限制：<br>key的对象，必须正确的实现了 Compare 接口<br>如果没有实现 Compare 接口，或者实现得不正确（比方说所有 Compare 方法都返回0）<br>那 JDK1.8 的 HashMap 其实还是慢于 JDK1.7 的</p><h2 id="3-3、HashTable接口"><a href="#3-3、HashTable接口" class="headerlink" title="3.3、HashTable接口"></a>3.3、HashTable接口</h2><p>HashTable和HashMap功能类似，都是用来保存键值对，但两者之间又有区别<br>区别：<br>1.HashTable中不允许保存null的，而HashMap可以保存空的null和value<br>2…HashTable是同步的，因此它是线程安全的<br>HashMap线程不安全<br>3.Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口</p><p>使用举例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> ThreeWeek<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Enumeration<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Hashtable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Iterator<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashTableTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Hashtable<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hashtable</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//[1]添加元素</span>        table<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        table<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"lisi"</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        table<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"wangwu"</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//[2]toString()方式打印</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>table<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//[3]Iterator遍历方式1--键值对遍历entrySet()</span>        Iterator<span class="token operator">&lt;</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span> iter <span class="token operator">=</span> table<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> entry <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">)</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String key <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> value <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"entrySet:"</span><span class="token operator">+</span>key<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===================================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//[4]Iterator遍历方式2--key键的遍历</span>        Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> table<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String key <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> value <span class="token operator">=</span> table<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"keySet:"</span><span class="token operator">+</span>key<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===================================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//[5]通过Enumeration来遍历Hashtable</span>        Enumeration<span class="token operator">&lt;</span>String<span class="token operator">></span> enu <span class="token operator">=</span> table<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>enu<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Enumeration:"</span><span class="token operator">+</span>table<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>enu<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>{zhangsan=22, lisi=33, wangwu=44}entrySet:zhangsan 22entrySet:lisi 33entrySet:wangwu 44====================================keySet:zhangsan 22keySet:lisi 33keySet:wangwu 44====================================Enumeration:java.util.Hashtable$Enumerator@139a55 zhangsanEnumeration:java.util.Hashtable$Enumerator@1db9742 lisiEnumeration:java.util.Hashtable$Enumerator@106d69c wangwu</code></pre><h2 id="3-4、LinkedHashMap"><a href="#3-4、LinkedHashMap" class="headerlink" title="3.4、LinkedHashMap"></a>3.4、LinkedHashMap</h2><p>多数情况下，只要不涉及线程安全问题，Map基本都可以使用HashMap，不过HashMap有一个问题，就是<strong>迭代HashMap的顺序并不是HashMap放置的顺序</strong>，也就是无序。HashMap的这一缺点往往会带来困扰，因为有些场景，我们期待一个有序的Map。</p><p>这个时候，LinkedHashMap就闪亮登场了，它虽然增加了时间和空间上的开销，但是<strong>通过维护一个运行于所有条目的双向链表，LinkedHashMap保证了元素迭代的顺序</strong>。<strong>该迭代顺序可以是插入顺序或者是访问顺序。</strong></p><table><thead><tr><th><strong>关  注  点</strong></th><th><strong>结    论</strong></th></tr></thead><tbody><tr><td>LinkedHashMap是否允许空</td><td>Key和Value都允许空</td></tr><tr><td>LinkedHashMap是否允许重复数据</td><td>Key重复会覆盖、Value允许重复</td></tr><tr><td>LinkedHashMap是否有序</td><td><strong>有序</strong></td></tr><tr><td>LinkedHashMap是否线程安全</td><td>非线程安全</td></tr></tbody></table><p>关于LinkedHashMap：<br>1、LinkedHashMap可以认为是<strong>HashMap+LinkedList</strong>，即它既使用HashMap操作数据结构，又使用LinkedList维护插入元素的先后顺序。<br>2、LinkedHashMap的基本实现思想就是—-<strong>多态</strong>。可以说，理解多态，再去理解LinkedHashMap原理会事半功倍；反之也是，对于LinkedHashMap原理的学习，也可以促进和加深对于多态的理解。</p><h2 id="3-5、TreeMap"><a href="#3-5、TreeMap" class="headerlink" title="3.5、TreeMap"></a>3.5、TreeMap</h2><p>TreeMap 是一个<strong>有序的key-value集合</strong>，它是通过<a href="http://www.cnblogs.com/skywang12345/p/3245399.html" target="_blank" rel="noopener">红黑树</a>实现的。<br>TreeMap <strong>继承于AbstractMap</strong>，所以它是一个Map，即一个key-value集合。<br>TreeMap 实现了NavigableMap接口，意味着它<strong>支持一系列的导航方法。</strong>比如返回有序的key集合。<br>TreeMap 实现了Cloneable接口，意味着<strong>它能被克隆</strong>。<br>TreeMap 实现了java.io.Serializable接口，意味着<strong>它支持序列化</strong>。</p><p>TreeMap基于<strong>红黑树（Red-Black tree）实现</strong>。该映射根据<strong>其键的自然顺序进行排序</strong>，或者根据<strong>创建映射时提供的 Comparator 进行排序</strong>，具体取决于使用的构造方法。<br>TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。<br>另外，TreeMap是<strong>非同步</strong>的。 它的iterator 方法返回的<strong>迭代器是fail-fastl</strong>的。</p><p> 与Map关系：</p><p><img src="img/TreeMap.jpg" alt=""></p><p>从图中可以看出：<br>(01) TreeMap实现继承于AbstractMap，并且实现了NavigableMap接口。<br>(02) TreeMap的本质是R-B Tree(红黑树)，它包含几个重要的成员变量： root, size, comparator。<br>　　root 是红黑数的根节点。它是Entry类型，Entry是红黑数的节点，它包含了红黑数的6个基本组成成分：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)。Entry节点根据key进行排序，Entry节点包含的内容为value。<br>　　红黑数排序时，根据Entry中的key进行排序；Entry中的key比较大小是根据比较器comparator来进行判断的。<br>　　size是红黑数中节点的个数。</p><h2 id="3-6、区别比较"><a href="#3-6、区别比较" class="headerlink" title="3.6、区别比较"></a>3.6、区别比较</h2><h3 id="3-6-1、HashMap和HashSet区别"><a href="#3-6-1、HashMap和HashSet区别" class="headerlink" title="3.6.1、HashMap和HashSet区别"></a>3.6.1、HashMap和HashSet区别</h3><p><img src="img/HashMap%E5%92%8CHashSet%E5%8C%BA%E5%88%AB" alt="image-20200701201313163"></p><h3 id="3-6-2、HashMap-和-HashTable-区别"><a href="#3-6-2、HashMap-和-HashTable-区别" class="headerlink" title="3.6.2、HashMap 和 HashTable 区别?"></a>3.6.2、HashMap 和 HashTable 区别?</h3><p>（1）基类不同：HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是什么？它是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的骨干实现，它以最大限度地减少实现此接口所需的工作。</p><p>（2）null不同：HashMap可以允许存在一个为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。</p><p>（3）线程安全：HashMap时单线程安全的，Hashtable是多线程安全的。由于非线程安全,HashMap 的效率要较 HashTable 的效率高一些.</p><p>（4）遍历不同：HashMap仅支持Iterator的遍历方式，Hashtable支持Iterator和Enumeration两种遍历方式。</p><p>（5）实现同步：HashTable 是 sychronize,多个线程访问时不需要自己为它的方法实现同步,而 HashMap 在被多个线程访问的时<br>候需要自己为它的方法实现同步;</p><h3 id="3-6-3、Linkedhashmap-与-hashmap-的区别"><a href="#3-6-3、Linkedhashmap-与-hashmap-的区别" class="headerlink" title="3.6.3、Linkedhashmap 与 hashmap 的区别"></a>3.6.3、Linkedhashmap 与 hashmap 的区别</h3><ol><li>LinkedHashMap 是 HashMap 的子类</li><li>LinkedHashMap 中的 Entry 增加了两个指针 before 和 after，它们分别用于维护<br>双向链接列表。</li><li>在 put 操作上，虽然 LinkedHashMap 完全继承了 HashMap 的 put 操作，但是在细<br>节上还是做了一定的调整，比如，在 LinkedHashMap 中向哈希表中插入新 Entry 的同时，还会通过 Entry 的 addBefore 方法将其链入到双向链表中。</li><li>在扩容操作上，虽然 LinkedHashMap 完全继承了 HashMap 的 resize 操作，但是 鉴于性能和 LinkedHashMap 自身特点的考量，LinkedHashMap 对其中的重哈希过 程(transfer 方法)进行了重写</li><li>在读取操作上，LinkedHashMap 中重写了 HashMap 中的 get 方法，通过 HashMap 中的 getEntry 方法获取 Entry 对象。在此基础上，进一步获取指定键对应的值。</li></ol><h1 id="四、Collections"><a href="#四、Collections" class="headerlink" title="四、Collections"></a>四、Collections</h1><h2 id="4-1-常用功能"><a href="#4-1-常用功能" class="headerlink" title="4.1 常用功能"></a>4.1 常用功能</h2><ul><li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li></ul><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code>:往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li></ul><p>代码演示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CollectionsDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//原来写法</span>        <span class="token comment" spellcheck="true">//list.add(12);</span>        <span class="token comment" spellcheck="true">//list.add(14);</span>        <span class="token comment" spellcheck="true">//list.add(15);</span>        <span class="token comment" spellcheck="true">//list.add(1000);</span>        <span class="token comment" spellcheck="true">//采用工具类 完成 往集合中添加元素  </span>        Collections<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">222</span><span class="token punctuation">,</span> <span class="token number">1</span>，<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//排序方法 </span>        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>结果：<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">222</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">222</span><span class="token punctuation">]</span></code></pre><p>代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？</p><p>我们发现还有个方法没有讲，<code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。</p><h2 id="4-2-Comparator比较器"><a href="#4-2-Comparator比较器" class="headerlink" title="4.2 Comparator比较器"></a>4.2 Comparator比较器</h2><p>我们还是先研究这个方法</p><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p><p>不过这次存储的是字符串类型。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CollectionsDemo2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span>  list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"cba"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"aba"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"sba"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"nba"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//排序方法</span>        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：</p><pre><code>[aba, cba, nba, sba]</code></pre><p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p><p>说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p><p>那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span></code></pre><p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</p><ul><li><p><code>public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p><blockquote><p>两个对象比较的结果有三种：大于，等于，小于。</p><p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p></blockquote></li></ul><p>操作如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CollectionsDemo3</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"cba"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"aba"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"sba"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"nba"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//排序方法  按照第一个单词的降序</span>        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>String o1<span class="token punctuation">,</span> String o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> o2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-</span> o1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果如下：</p><pre><code>[sba, nba, cba, aba]</code></pre><h2 id="4-3-简述Comparable和Comparator两个接口的区别。"><a href="#4-3-简述Comparable和Comparator两个接口的区别。" class="headerlink" title="4.3 简述Comparable和Comparator两个接口的区别。"></a>4.3 简述Comparable和Comparator两个接口的区别。</h2><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p><p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p><h2 id="4-4-练习"><a href="#4-4-练习" class="headerlink" title="4.4  练习"></a>4.4  练习</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p><p>Student 初始类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Student</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Student{"</span> <span class="token operator">+</span>               <span class="token string">"name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>               <span class="token string">", age="</span> <span class="token operator">+</span> age <span class="token operator">+</span>               <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>测试类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建四个学生对象 存储到集合中</span>        ArrayList<span class="token operator">&lt;</span>Student<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Student<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"rose"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"jack"</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"ace"</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"mark"</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*          让学生 按照年龄排序 升序         */</span><span class="token comment" spellcheck="true">//        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Student student <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>发现，当我们调用Collections.sort()方法的时候 程序报错了。</p><p>原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。</p><p>于是我们就完成了Student类的一个实现，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Student<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Student o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">-</span>o<span class="token punctuation">.</span>age<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//升序</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>再次测试，代码就OK 了效果如下：</p><pre class=" language-java"><code class="language-java">Student<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'jack'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">}</span>Student<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'abc'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">}</span>Student<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'mark'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">}</span>Student<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'ace'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">17</span><span class="token punctuation">}</span>Student<span class="token punctuation">{</span>name<span class="token operator">=</span><span class="token string">'rose'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">}</span></code></pre><h2 id="4-5-扩展"><a href="#4-5-扩展" class="headerlink" title="4.5 扩展"></a>4.5 扩展</h2><p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则：</p><pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Student<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Student o1<span class="token punctuation">,</span> Student o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> o2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>o1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//以学生的年龄降序</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>效果：</p><pre><code>Student{name=&#39;rose&#39;, age=18}Student{name=&#39;ace&#39;, age=17}Student{name=&#39;jack&#39;, age=16}Student{name=&#39;abc&#39;, age=16}Student{name=&#39;mark&#39;, age=16}</code></pre><p>如果想要规则更多一些，可以参考下面代码：</p><pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Student<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Student o1<span class="token punctuation">,</span> Student o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 年龄降序</span>                <span class="token keyword">int</span> result <span class="token operator">=</span> o2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>o1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//年龄降序</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//第一个规则判断完了 下一个规则 姓名的首字母 升序</span>                    result <span class="token operator">=</span> o1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-</span>o2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>效果如下：</p><pre><code>Student{name=&#39;rose&#39;, age=18}Student{name=&#39;ace&#39;, age=17}Student{name=&#39;abc&#39;, age=16}Student{name=&#39;jack&#39;, age=16}Student{name=&#39;mark&#39;, age=16}</code></pre><p>参考：</p><p><a href="https://blog.csdn.net/qq_41150890/article/details/107001996" target="_blank" rel="noopener">https://blog.csdn.net/qq_41150890/article/details/107001996</a></p><p><a href="https://www.jianshu.com/p/20a56b81157e" target="_blank" rel="noopener">https://www.jianshu.com/p/20a56b81157e</a></p><p><a href="https://blog.csdn.net/CSDNWeiZhiQiang/article/details/82870111" target="_blank" rel="noopener">https://blog.csdn.net/CSDNWeiZhiQiang/article/details/82870111</a></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>if语句与if else if else语句与if else语句与if if if语句</title>
      <link href="/2018/05/03/C++/if%E8%AF%AD%E5%8F%A5%E4%B8%8Eif%20else%20if%20else%E8%AF%AD%E5%8F%A5%E4%B8%8Eif%20else%E8%AF%AD%E5%8F%A5%E4%B8%8Eif%20if%20if%E8%AF%AD%E5%8F%A5/"/>
      <url>/2018/05/03/C++/if%E8%AF%AD%E5%8F%A5%E4%B8%8Eif%20else%20if%20else%E8%AF%AD%E5%8F%A5%E4%B8%8Eif%20else%E8%AF%AD%E5%8F%A5%E4%B8%8Eif%20if%20if%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="if语句与if-else-if-else语句与if-else语句与if-if-if语句"><a href="#if语句与if-else-if-else语句与if-else语句与if-if-if语句" class="headerlink" title="if语句与if else if else语句与if else语句与if if if语句"></a>if语句与if else if else语句与if else语句与if if if语句</h1><h2 id="1-if型"><a href="#1-if型" class="headerlink" title="1. if型"></a>1. if型</h2><p>结构：</p><p>if(某个条件)</p><p>​    语句;</p><p>使用场景:</p><p>当满足这个条件时,执行某个操作,而不满足该条件时,什么都不做.在这种情况下就可以使用这种结构</p><h2 id="2-if-else型"><a href="#2-if-else型" class="headerlink" title="2. if else型"></a>2. if else型</h2><p>结构：</p><p>if(某个条件)</p><p>​    语句1;</p><p>else</p><p>​    语句2;</p><p>使用场景:</p><p>当满足这个条件时,执行某个操作,当不满足这个条件时,执行另一个操作(和if型区别是如果不满足条件一个是执行另一个操作,而一个是什么都不做)</p><h2 id="3-if-else-if-else型"><a href="#3-if-else-if-else型" class="headerlink" title="3. if else if else型"></a>3. if else if else型</h2><p>结构：</p><p>if(条件1)</p><p>​    语句1;</p><p>else if(条件2)</p><p>​    语句2;</p><p>else if(条件3)</p><p>​    语句3;</p><p>  ···</p><p>​    .</p><p>​    .</p><p>else</p><p>​    语句4;</p><p>1.使用场景:</p><p>这种形式的if语句,最终只有一个出口.即当满足条件1时,执行语句1.当不满足条件1时,往下走,判断是否满足条件2,如果还是不满足,则继续往下走,一直走到else语句,说明之前的条件都不满足,最终执行语句4;</p><p>这个和之前两个的区别是:它存在了多种情况的分析,而之前两个仅仅只有一种情况的分析.</p><p>2.if elseif else 与if 嵌套的区别:</p><p>if套if,是当外面条件不满足时,里面的if不会执行</p><p>而if else if else,是当第一个条件不满足时,判断第二个条件</p><h2 id="4、多个if"><a href="#4、多个if" class="headerlink" title="4、多个if"></a>4、多个if</h2><p>最后我们来看看多个if的类型</p><p>if(条件1)</p><p>​    语句1;</p><p>if(条件2)</p><p>​    语句2;</p><p>if(条件3)</p><p>​    语句3;</p><p>解释一下:有没有发现特别像if else if else型,但是二者是有区别的.</p><p>分析一下多个if:当满足条件1时,执行语句1.当不满足条件1时,往下走,判断条件2,如果还是不满足,再判断条件3.这么看好像和if else if else型没什么区别.</p><p>我们看个例子就明白了</p><p>多个if型:</p><pre class=" language-c++"><code class="language-c++">int a=0;if(a==0){​    a++;​    printf("aaa");}   if(a==1)​    printf("bbb");if(a==2)​    printf("ccc");  </code></pre><p>最终输出:aaabbb,在多个if语句中,所有的if都会进行判断,无论是否满足情况.所以在满足a==0时,执行了a++,a就变成了1,当进行a==1判断时,也符合,故也执行了printf(“bbb”)</p><p>-————————————————</p><p>if else if else型:</p><pre class=" language-c++"><code class="language-c++">int a=0;if(a==0){​    a++;​    printf("aaa");}   else if(a==1)​    printf("bbb");else​    printf("ccc");  </code></pre><p>最终只输出了aaa.在if else if else中,只要有一个条件满足,则其余条件不用判断,直接跳过即可</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全局变量，局部变量，静态变量和常量</title>
      <link href="/2018/03/01/C++/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"/>
      <url>/2018/03/01/C++/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="全局变量，局部变量，静态变量和常量"><a href="#全局变量，局部变量，静态变量和常量" class="headerlink" title="全局变量，局部变量，静态变量和常量"></a>全局变量，局部变量，静态变量和常量</h1><h2 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1. 全局变量"></a>1. 全局变量</h2><pre><code>      全局变量是在所有函数体的外部定义的，**程序的所有部分（其他文件的代码）都可以使用**。全局变量不受作用域的影响。全局变量的生命周期一直到程序的结束，全局变量是静态存储方式。如果在一个文件中使用extern关键字来声明另一个文件中存在的全局变量，那么这个文件可以使用这个变量。通常都是在一个.CPP文件的开始声明这个变量，在其他需要用到这个变量的地方其头文件也就是.h文件中extern  type vari;</code></pre><h2 id="2-局部变量（自动变量、寄存器变量）"><a href="#2-局部变量（自动变量、寄存器变量）" class="headerlink" title="2. 局部变量（自动变量、寄存器变量）"></a>2. 局部变量（自动变量、寄存器变量）</h2><pre><code>     局部变量出现在一个作用域内，它们是局限于一个函数的。局部变量经常被称为自动变量，因为它们**在进入作用域时，自动生成，离开作用域时自动消失**。关键字auto可以显示的说明这个问题，但局部变量默认为auto，所以没必要声明为auto。通常函数里定义的变量，函数的参数都局部变量。所以一般需要在某个函数里，返回数组的地址或者指针之类，这时候必须定义成static,或者动态申请内存，这样函数结束返回时才不会释放掉那块内存空间。</code></pre><p>寄存器变量也是一种局部变量。register来修饰，就是告诉编译器尽可能快的访问这个变量,通过存放在寄存器中来实现快速访问。</p><h2 id="3-静态变量"><a href="#3-静态变量" class="headerlink" title="3. 静态变量"></a>3. 静态变量</h2><pre><code>      静态变量的修饰关键字是static，static可以作用于变量以及函数。由static修饰的，可分为静态局部变量，静态全局变量，静态函数。静态变量的生命期和程序生命期是一样的，在程序结束之后操作系统会回收空间。 静态变量当然是属于静态存储方式，但是属于静态存储方式的量不一定就是静态变量。 例如外部变量虽属于静态存储方式，但不一定是静态变量，必须由 static加以定义后才能成为静态外部变量，或称静态全局变量。</code></pre><p>！C++中可以在类的数据成员或成员函数之前加上static，这样定义的数据成员或成员函数就被类所拥有，而不再属于类的对象。如下:</p><pre><code>&lt;span style=&quot;font-size:14px;&quot;&gt;class A{ char c; int a; static int b;}a ;//X86机器下，sizeof(a)=8 （字节对齐是4的倍数，静态成员变量不算）&lt;/span&gt;</code></pre><h3 id="lt-1-gt-静态局部变量"><a href="#lt-1-gt-静态局部变量" class="headerlink" title="&lt;1&gt;静态局部变量"></a>&lt;1&gt;静态局部变量</h3><p>在局部变量前面加上static后，就定义了静态局部变量,静态局部变量属于静态存储方式，<strong>静态局部变量只会被初始化一次，下次使用依据上一次保存的值</strong>。它具有以下特点：</p><p>(1) 静态局部变量<strong>在函数内定义</strong> ,它的<strong>生存期为整个源程序</strong>，<strong>但是其作用域仍与自动变量相同</strong>，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。(作用域不变，生存周期变了)</p><p>(2) <strong>允许对构造类静态局部量赋初值</strong> ，例如数组，若未赋以初值，则由系统自动赋以0值。（而非静态局部变量未赋初始值，系统会给个随机值）</p><p>(3) 对基本类型的静态局部变量，若在说明时未赋以初值，则系统自动赋予0值。而对自动变量没有赋初值，则其值是随机值。</p><p> 静态局部变量是一种生存期为整个源程序的量。虽然离开定义它的函数后不能使用，但如再次调用定义它的函数时，它又可继续使用， 而且保存了上次被调用后留下的值。 因此，当多次调用一个函数且要求在调用之间保留某些变量的值时，可考虑采用静态局部变量。虽然用全局变量也可以达到上述目的，但全局变量有时会造成意外的副作用，因此仍以采用局部静态变量为宜。</p><pre><code>&lt;span style=&quot;font-size:14px;&quot;&gt;//静态局部变量int Fun(){static int n = 0;++n;return n;}for(int i = 0; i &lt; 5; i++){cout&lt;&lt;Fun()&lt;&lt;&quot; &quot;;}/*输出结果是1 2 3 4 5 //这里只初始化一次，每次调用都是依据上一次保存的值。&lt;/span&gt;</code></pre><h3 id="lt-2-gt-静态全局变量"><a href="#lt-2-gt-静态全局变量" class="headerlink" title="&lt;2&gt; 静态全局变量"></a>&lt;2&gt; 静态全局变量</h3><p>　　<strong>全局变量(外部变量)的说明之前再加static 就构成了静态全局变量</strong>。<strong>static全局变量只初使化一次</strong>，防止在其他文件单元中被引用。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。</p><p>综上：<strong>把局部变量改变为静态局部变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态全局变量是改变了它的作用域， 限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。</strong></p><pre><code>//测试静态全局变量&lt;span style=&quot;font-size:14px;&quot;&gt;staticint value;voidfun(){value= 0;++value;}for(inti = 0; i &lt; 5; i++){fun();cout&lt;&lt;value&lt;&lt;&quot;&quot;;}/*输出1 1 1 1 1 。静态全局变量可以被多次赋值为0.&lt;/span&gt;</code></pre><h3 id="lt-3-gt-static-函数"><a href="#lt-3-gt-static-函数" class="headerlink" title="&lt;3&gt; static 函数"></a>&lt;3&gt; static 函数</h3><p>  Statci函数和普通函数作用域不同，它的作用只在定义它的本文件中。如果只在当前源文件中调用的函数，应说明为内部函数（static）。下面说下内部函数和外部函数：</p><p>  内部函数和外部函数:当一个源程序由多个源文件组成时，C语言根据函数能否被其它源文件中的函数调用，将函数分为内部函数和外部函数。</p><p>(1) 内部函数（又称静态函数）</p><p>　　如果在一个源文件中定义的函数，只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用，这种函数称为内部函数。<strong>定义一个内部函数，只需在函数类型前再加一个“static”关键字即可</strong>，如下所示：</p><p>　　　static 函数类型 函数名(函数参数表) {}</p><p>内部函数又称静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件。使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名，因为同名也没有关系。</p><p>(2) 外部函数</p><p>　　外部函数的定义：在定义函数时，<strong>如果没有加关键字“static”，或冠以关键字“extern”，表示此函数是外部函数：</strong></p><p>　　　　[extern] 函数类型 函数名(函数参数表) {}</p><p>调用外部函数时，需要对其进行说明：</p><p>​        [extern] 函数类型 函数名(参数类型表)[，函数名2(参数类型表2)……]；</p><p>static函数和普通函数的区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份复制品。在类中，静态成员函数不需要类的对象来调用，直接类调用：</p><pre><code>classA{ static voidtest() {}};A::test();</code></pre><p>静态成员函数只能访问静态成员变量，静态成员变量必须单独初始化。静态成员函数可定义为inline函数。</p><h3 id="lt-4-gt-类的static-成员和函数"><a href="#lt-4-gt-类的static-成员和函数" class="headerlink" title="&lt;4&gt;  类的static 成员和函数"></a>&lt;4&gt;  类的static 成员和函数</h3><p>（1）当将类的某个数据成员声明为static时，该静态数据成员只能被定义一次，而且要被同类的所有对象共享。各个对象都拥有类中每一个普通数据成员的副本，但静态数据成员只有一个实例存在，与定义了多少类对象无关。静态方法就是与该类相关的，是类的一种行为，而不是与该类的实例对象相关。</p><p>（2） 静态数据成员不能在类中初始化，也不能在类的构造函数中初始化该成员，因为静态数据成员为类的各个对象共享，否则每次创建一个类的对象则静态数据成员都要被重新初始化。</p><p>（3） 静态成员不可在类体内进行赋值，因为它是被所有该类的对象所共享的。你在一个对象里给它赋值，其他对象里的该成员也会发生变化。为了避免混乱，所以不可在类体内进行赋值。</p><p>（4） 静态成员的值对所有的对象是一样的。静态成员可以被初始化，但只能在类体外进行初始化。</p><p>（5） 它在对象中不占用存储空间，这个属性为整个类所共有，不属于任何一个具体对象</p><p>（6）静态函数成员必须通过对象名来访问非静态数据成员。另外，静态成员函数在类外实现时候无须加static关键字，否则是错误的。</p><p>（7）静态成员函数可以直接访问该类的静态数据和函数成员，而访问非静态数据成员必须通过参数传递的方式得到一个对象名，然后通过对象名来访问。</p><p>static关键字至少下列几个作用：  </p><p>（1）函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；  </p><p>（2）在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；  </p><p>（3）在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；  </p><p>（4）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；  </p><p>（5）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。 </p><h2 id="4-外部变量"><a href="#4-外部变量" class="headerlink" title="4. 外部变量"></a>4. 外部变量</h2><p> 在全局变量那已经提了external关键字，它就是告诉编译器存在一个变量或函数，即使在当前的编译的文件中没有看到它，这个变量或函数可能在另一个文件中或者在当前文件的后面定义。</p><p> ！！！如果一个变量i，它已经被定义为static，限定了作用域，这时你再用extern定义它是全局的，编译器就会报错。</p><h2 id="5-常量"><a href="#5-常量" class="headerlink" title="5. 常量"></a>5. 常量</h2><p>在旧版C中，通常建立一个常量，必须使用预处理器：</p><p>#define  PI  3.14159</p><p>而C++用const来修饰常量，并加进了标准C中。一旦定义了常量，就不能再去修改它的值。如果初始化没给常量赋值，那它就是一个随机数，并且以后也不能给它赋值。C和C++中const的使用还是不同的，虽然const标记着“不会被改变”（见下题）。</p><p><span style="font-size:14px;">在c++中，</p><p>const int i=0 ;</p><p>int* j = (int *)&i;</p><p>*j =1;</p><p>Printf(“ %d ,%d”,i,*j);   </p><p>输出是多少?</p><p>A 0，1</p><p>B 1，1</p><p>C 1，0</p><p>D 0，0</span></p><p>答案是A，C++中i被定义为常量，在编译阶段就将常量i相当于宏定义，确定了它的初始值，C++在后面输出i时只是将i用初始值来做替换，和宏定义一样，而没有去读i的内存的值，所以输出i为0，而j是访问i的内存里的值，这里其实已经被改为1 了！而C中是运行时，const才确定值，将会输出它的值（被改变的），上题在C中运行结果就是1，1</p><p>大家可能对于const 修饰指针有点迷惑，下面几个：</p><p><span style="font-size:14px;">int b=1;</p><p>int c=2;</p><p>const int* a1=&b;</p><p>int const* a2=&b;</p><p>int * const a3=&b;</p><p>const int* const a4=&b;</p><p>a1=&c; //这三个都正确</p><p>a2=&c;</p><p>*a3=3;</span></p><p>a1和a2一样，const都是修饰指针所指向的变量，即指针指向是常量，所以不能修改指针指向的内容，但可以修改指针的本身。</p><p>a3中const修饰的是指针本身，即指针本身是常量。所以不能修改指针本身，但可以修改指针指向的内容。</p><p>a4中const int* const类型。即不能修改指针本身也不能修改指向的内容。</p><p>  关于常量的补充：</p><p> 常量指针和指针常量的区别：</p><p>常量指针p1：指向的地址可以变，但内容不可以重新赋值，内容的改变只能通过修改地址指向后变换。  </p><p>  p1 = &amp;a是正确的，但 *p1 = a是错误的。</p><p>指针常量p2：指向的地址不可以重新赋值，但内容可以改变，必须初始化，地址跟随一生。</p><p>  p2= &amp;a是错误的，而*p2 = a 是正确的。</p><p>总结：对于const int * a ， int * const a ,这样的，最简单的区分方式就是： const 如果在 <em>前面，那么这是常量指针，指针指向的地址的值不能改，但本身指针可以改，指向别的地址； 如果const 在</em>后面，那么这是指针常量，指针本身是常量，不可以改指向了，但可以修改它指向地址的值。</p><p>const关键字至少以下作用：  </p><p>（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；  </p><p>（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；  </p><p>（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；  </p><p>（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的 成员变量；  </p><p>（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。  </p><p>小结：从存储空间分配来说，全局变量、静态全局变量、静态局部变量都是在静态存储区（全局数据区）中分配空间的，而局部变量是在栈上分配空间的。常量存储在常量区。全局/静态存储区，是在程序编译时就已经分配好的，在整个运行期间都存在。而栈区系统自动释放（静态分配内存），预编译阶段就确定好了大小，栈区存放函数的参数值、局部变量的值。而new，malloc是在堆区申请内存，然后手动通过delete，free释放掉。不过要注意区分，new/delete是运算符，会调用构造和析构函数，而malloc/free是库函数，不会调用构造和析构。</p><p> 关于数据段：  </p><p>  BSS段：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。</p><p>数据段：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</p><p>代码段：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p><p>堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</p><p>栈(stack)：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
